// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import 'frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

/// Active connection for tracking
class ActiveConnection {
  final String id;
  final String inboundTag;
  final String outboundTag;
  final String host;
  final String? destinationIp;
  final int destinationPort;
  final String protocol;
  final String network;
  final BigInt uploadBytes;
  final BigInt downloadBytes;
  final BigInt startTime;
  final String rule;
  final String rulePayload;
  final String? processName;

  const ActiveConnection({
    required this.id,
    required this.inboundTag,
    required this.outboundTag,
    required this.host,
    this.destinationIp,
    required this.destinationPort,
    required this.protocol,
    required this.network,
    required this.uploadBytes,
    required this.downloadBytes,
    required this.startTime,
    required this.rule,
    required this.rulePayload,
    this.processName,
  });

  @override
  int get hashCode =>
      id.hashCode ^
      inboundTag.hashCode ^
      outboundTag.hashCode ^
      host.hashCode ^
      destinationIp.hashCode ^
      destinationPort.hashCode ^
      protocol.hashCode ^
      network.hashCode ^
      uploadBytes.hashCode ^
      downloadBytes.hashCode ^
      startTime.hashCode ^
      rule.hashCode ^
      rulePayload.hashCode ^
      processName.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ActiveConnection &&
          runtimeType == other.runtimeType &&
          id == other.id &&
          inboundTag == other.inboundTag &&
          outboundTag == other.outboundTag &&
          host == other.host &&
          destinationIp == other.destinationIp &&
          destinationPort == other.destinationPort &&
          protocol == other.protocol &&
          network == other.network &&
          uploadBytes == other.uploadBytes &&
          downloadBytes == other.downloadBytes &&
          startTime == other.startTime &&
          rule == other.rule &&
          rulePayload == other.rulePayload &&
          processName == other.processName;
}

/// Connection DTO (Design Document Compliant)
class ConnectionDto {
  final String id;
  final String srcAddr;
  final String dstAddr;
  final String? dstDomain;
  final String protocol;
  final String outbound;
  final BigInt upload;
  final BigInt download;
  final PlatformInt64 startTime;
  final String? rule;

  const ConnectionDto({
    required this.id,
    required this.srcAddr,
    required this.dstAddr,
    this.dstDomain,
    required this.protocol,
    required this.outbound,
    required this.upload,
    required this.download,
    required this.startTime,
    this.rule,
  });

  @override
  int get hashCode =>
      id.hashCode ^
      srcAddr.hashCode ^
      dstAddr.hashCode ^
      dstDomain.hashCode ^
      protocol.hashCode ^
      outbound.hashCode ^
      upload.hashCode ^
      download.hashCode ^
      startTime.hashCode ^
      rule.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ConnectionDto &&
          runtimeType == other.runtimeType &&
          id == other.id &&
          srcAddr == other.srcAddr &&
          dstAddr == other.dstAddr &&
          dstDomain == other.dstDomain &&
          protocol == other.protocol &&
          outbound == other.outbound &&
          upload == other.upload &&
          download == other.download &&
          startTime == other.startTime &&
          rule == other.rule;
}

/// Connection information
class ConnectionInfo {
  final String id;
  final String host;
  final String destination;
  final BigInt upload;
  final BigInt download;
  final BigInt startTime;
  final String rule;
  final List<String> chains;

  const ConnectionInfo({
    required this.id,
    required this.host,
    required this.destination,
    required this.upload,
    required this.download,
    required this.startTime,
    required this.rule,
    required this.chains,
  });

  @override
  int get hashCode =>
      id.hashCode ^
      host.hashCode ^
      destination.hashCode ^
      upload.hashCode ^
      download.hashCode ^
      startTime.hashCode ^
      rule.hashCode ^
      chains.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ConnectionInfo &&
          runtimeType == other.runtimeType &&
          id == other.id &&
          host == other.host &&
          destination == other.destination &&
          upload == other.upload &&
          download == other.download &&
          startTime == other.startTime &&
          rule == other.rule &&
          chains == other.chains;
}

/// DNS config DTO (Design Document Compliant)
class DnsConfigDto {
  final bool enable;
  final String listen;
  final String enhancedMode;
  final List<String> nameservers;
  final List<String> fallback;

  const DnsConfigDto({
    required this.enable,
    required this.listen,
    required this.enhancedMode,
    required this.nameservers,
    required this.fallback,
  });

  @override
  int get hashCode =>
      enable.hashCode ^
      listen.hashCode ^
      enhancedMode.hashCode ^
      nameservers.hashCode ^
      fallback.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is DnsConfigDto &&
          runtimeType == other.runtimeType &&
          enable == other.enable &&
          listen == other.listen &&
          enhancedMode == other.enhancedMode &&
          nameservers == other.nameservers &&
          fallback == other.fallback;
}

/// Latency test result
class LatencyTestResult {
  final String proxyName;
  final int? latencyMs;
  final bool success;
  final String? error;

  const LatencyTestResult({
    required this.proxyName,
    this.latencyMs,
    required this.success,
    this.error,
  });

  @override
  int get hashCode =>
      proxyName.hashCode ^
      latencyMs.hashCode ^
      success.hashCode ^
      error.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is LatencyTestResult &&
          runtimeType == other.runtimeType &&
          proxyName == other.proxyName &&
          latencyMs == other.latencyMs &&
          success == other.success &&
          error == other.error;
}

/// Proxy group DTO (Design Document Compliant)
class ProxyGroupDto {
  final String tag;
  final String groupType;
  final List<String> proxies;
  final String selected;

  const ProxyGroupDto({
    required this.tag,
    required this.groupType,
    required this.proxies,
    required this.selected,
  });

  @override
  int get hashCode =>
      tag.hashCode ^ groupType.hashCode ^ proxies.hashCode ^ selected.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ProxyGroupDto &&
          runtimeType == other.runtimeType &&
          tag == other.tag &&
          groupType == other.groupType &&
          proxies == other.proxies &&
          selected == other.selected;
}

/// Proxy info DTO (Design Document Compliant)
class ProxyInfoDto {
  final String tag;
  final String protocolType;
  final String? server;
  final int? port;
  final BigInt? latencyMs;
  final bool alive;

  const ProxyInfoDto({
    required this.tag,
    required this.protocolType,
    this.server,
    this.port,
    this.latencyMs,
    required this.alive,
  });

  @override
  int get hashCode =>
      tag.hashCode ^
      protocolType.hashCode ^
      server.hashCode ^
      port.hashCode ^
      latencyMs.hashCode ^
      alive.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ProxyInfoDto &&
          runtimeType == other.runtimeType &&
          tag == other.tag &&
          protocolType == other.protocolType &&
          server == other.server &&
          port == other.port &&
          latencyMs == other.latencyMs &&
          alive == other.alive;
}

/// Proxy latency DTO (Design Document Compliant)
class ProxyLatencyDto {
  final String tag;
  final BigInt? latencyMs;
  final String? error;

  const ProxyLatencyDto({required this.tag, this.latencyMs, this.error});

  @override
  int get hashCode => tag.hashCode ^ latencyMs.hashCode ^ error.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ProxyLatencyDto &&
          runtimeType == other.runtimeType &&
          tag == other.tag &&
          latencyMs == other.latencyMs &&
          error == other.error;
}

/// Proxy status information
class ProxyStatus {
  final bool running;
  final int inboundCount;
  final int outboundCount;
  final int connectionCount;
  final BigInt memoryUsage;
  final BigInt uptime;

  const ProxyStatus({
    required this.running,
    required this.inboundCount,
    required this.outboundCount,
    required this.connectionCount,
    required this.memoryUsage,
    required this.uptime,
  });

  @override
  int get hashCode =>
      running.hashCode ^
      inboundCount.hashCode ^
      outboundCount.hashCode ^
      connectionCount.hashCode ^
      memoryUsage.hashCode ^
      uptime.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ProxyStatus &&
          runtimeType == other.runtimeType &&
          running == other.running &&
          inboundCount == other.inboundCount &&
          outboundCount == other.outboundCount &&
          connectionCount == other.connectionCount &&
          memoryUsage == other.memoryUsage &&
          uptime == other.uptime;
}

/// Rule DTO (Design Document Compliant)
class RuleDto {
  final String ruleType;
  final String payload;
  final String outbound;
  final BigInt matchedCount;

  const RuleDto({
    required this.ruleType,
    required this.payload,
    required this.outbound,
    required this.matchedCount,
  });

  @override
  int get hashCode =>
      ruleType.hashCode ^
      payload.hashCode ^
      outbound.hashCode ^
      matchedCount.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is RuleDto &&
          runtimeType == other.runtimeType &&
          ruleType == other.ruleType &&
          payload == other.payload &&
          outbound == other.outbound &&
          matchedCount == other.matchedCount;
}

/// System information
class SystemInfo {
  final String platform;
  final String version;
  final BigInt memoryTotal;
  final BigInt memoryUsed;
  final int cpuCores;
  final int cpuThreads;
  final String cpuName;
  final double cpuUsage;

  const SystemInfo({
    required this.platform,
    required this.version,
    required this.memoryTotal,
    required this.memoryUsed,
    required this.cpuCores,
    required this.cpuThreads,
    required this.cpuName,
    required this.cpuUsage,
  });

  @override
  int get hashCode =>
      platform.hashCode ^
      version.hashCode ^
      memoryTotal.hashCode ^
      memoryUsed.hashCode ^
      cpuCores.hashCode ^
      cpuThreads.hashCode ^
      cpuName.hashCode ^
      cpuUsage.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is SystemInfo &&
          runtimeType == other.runtimeType &&
          platform == other.platform &&
          version == other.version &&
          memoryTotal == other.memoryTotal &&
          memoryUsed == other.memoryUsed &&
          cpuCores == other.cpuCores &&
          cpuThreads == other.cpuThreads &&
          cpuName == other.cpuName &&
          cpuUsage == other.cpuUsage;
}

/// Traffic statistics
class TrafficStats {
  final BigInt upload;
  final BigInt download;
  final BigInt uploadSpeed;
  final BigInt downloadSpeed;

  const TrafficStats({
    required this.upload,
    required this.download,
    required this.uploadSpeed,
    required this.downloadSpeed,
  });

  @override
  int get hashCode =>
      upload.hashCode ^
      download.hashCode ^
      uploadSpeed.hashCode ^
      downloadSpeed.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is TrafficStats &&
          runtimeType == other.runtimeType &&
          upload == other.upload &&
          download == other.download &&
          uploadSpeed == other.uploadSpeed &&
          downloadSpeed == other.downloadSpeed;
}

/// Traffic statistics DTO (Design Document Compliant)
class TrafficStatsDto {
  final BigInt upload;
  final BigInt download;
  final BigInt totalUpload;
  final BigInt totalDownload;
  final int connectionCount;
  final BigInt uptimeSecs;

  const TrafficStatsDto({
    required this.upload,
    required this.download,
    required this.totalUpload,
    required this.totalDownload,
    required this.connectionCount,
    required this.uptimeSecs,
  });

  @override
  int get hashCode =>
      upload.hashCode ^
      download.hashCode ^
      totalUpload.hashCode ^
      totalDownload.hashCode ^
      connectionCount.hashCode ^
      uptimeSecs.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is TrafficStatsDto &&
          runtimeType == other.runtimeType &&
          upload == other.upload &&
          download == other.download &&
          totalUpload == other.totalUpload &&
          totalDownload == other.totalDownload &&
          connectionCount == other.connectionCount &&
          uptimeSecs == other.uptimeSecs;
}

/// TUN mode status
class TunStatus {
  final bool enabled;
  final String? interfaceName;
  final int? mtu;
  final String? error;

  const TunStatus({
    required this.enabled,
    this.interfaceName,
    this.mtu,
    this.error,
  });

  @override
  int get hashCode =>
      enabled.hashCode ^ interfaceName.hashCode ^ mtu.hashCode ^ error.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is TunStatus &&
          runtimeType == other.runtimeType &&
          enabled == other.enabled &&
          interfaceName == other.interfaceName &&
          mtu == other.mtu &&
          error == other.error;
}
