// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import 'frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'types.dart';

// These functions are ignored because they are not marked as `pub`: `convert_ffi_config_to_core`, `decrypt`, `encrypt`, `get_cpu_name`, `init_tracing_safe`, `new`, `next_nonce`, `ss_build_address_header`, `ss_cipher_spec`, `ss_derive_subkey`, `ss_recv_decrypted_chunk`, `test_via_http_proxy`
// These types are ignored because they are neither used by any `pub` functions nor (for structs and enums) marked `#[frb(unignore)]`: `SsAeadCipherInner`, `SsAeadCipher`, `SsCipherSpec`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`

Future<void> startProxyFromYaml({required String yamlConfig}) =>
    RustLib.instance.api.crateApiStartProxyFromYaml(yamlConfig: yamlConfig);

Future<void> startProxyFromFile({required String configPath}) =>
    RustLib.instance.api.crateApiStartProxyFromFile(configPath: configPath);

Future<void> stopProxy() => RustLib.instance.api.crateApiStopProxy();

Future<bool> isProxyRunning() => RustLib.instance.api.crateApiIsProxyRunning();

Future<void> reloadConfigFromYaml({required String yamlConfig}) =>
    RustLib.instance.api.crateApiReloadConfigFromYaml(yamlConfig: yamlConfig);

Future<void> reloadConfigFromFile({required String configPath}) =>
    RustLib.instance.api.crateApiReloadConfigFromFile(configPath: configPath);

/// Start proxy from a Clash-format configuration file
/// This automatically converts Clash config to VeloGuard format
Future<void> startProxyFromClashYaml({required String clashYaml}) =>
    RustLib.instance.api.crateApiStartProxyFromClashYaml(clashYaml: clashYaml);

/// Start proxy from a Clash-format configuration file
Future<void> startProxyFromClashFile({required String configPath}) => RustLib
    .instance
    .api
    .crateApiStartProxyFromClashFile(configPath: configPath);

/// Reload configuration from a Clash-format YAML string
Future<void> reloadConfigFromClashYaml({required String clashYaml}) => RustLib
    .instance
    .api
    .crateApiReloadConfigFromClashYaml(clashYaml: clashYaml);

/// Reload configuration from a Clash-format file
Future<void> reloadConfigFromClashFile({required String configPath}) => RustLib
    .instance
    .api
    .crateApiReloadConfigFromClashFile(configPath: configPath);

/// Download and start proxy from a subscription URL
/// This fetches the Clash config from the URL and starts the proxy
Future<void> startProxyFromUrl({required String url}) =>
    RustLib.instance.api.crateApiStartProxyFromUrl(url: url);

/// Download config from URL and return the YAML content
/// Useful for saving the config locally before starting
Future<String> downloadConfigFromUrl({required String url}) =>
    RustLib.instance.api.crateApiDownloadConfigFromUrl(url: url);

/// Convert a Clash config to VeloGuard format (for debugging/preview)
Future<String> convertClashToVeloguard({required String clashYaml}) =>
    RustLib.instance.api.crateApiConvertClashToVeloguard(clashYaml: clashYaml);

Future<TrafficStatsDto> getTrafficStatsDto() =>
    RustLib.instance.api.crateApiGetTrafficStatsDto();

Future<List<ConnectionDto>> getConnectionsDto() =>
    RustLib.instance.api.crateApiGetConnectionsDto();

Future<void> closeConnectionById({required String id}) =>
    RustLib.instance.api.crateApiCloseConnectionById(id: id);

Future<void> closeAllConnectionsDto() =>
    RustLib.instance.api.crateApiCloseAllConnectionsDto();

Future<List<ProxyInfoDto>> getProxies() =>
    RustLib.instance.api.crateApiGetProxies();

Future<List<ProxyGroupDto>> getProxyGroups() =>
    RustLib.instance.api.crateApiGetProxyGroups();

Future<void> selectProxy({
  required String groupTag,
  required String proxyTag,
}) => RustLib.instance.api.crateApiSelectProxy(
  groupTag: groupTag,
  proxyTag: proxyTag,
);

Future<BigInt> testProxyLatencyDto({
  required String tag,
  required String testUrl,
  required BigInt timeoutMs,
}) => RustLib.instance.api.crateApiTestProxyLatencyDto(
  tag: tag,
  testUrl: testUrl,
  timeoutMs: timeoutMs,
);

Future<List<ProxyLatencyDto>> testAllProxiesLatency({
  required String testUrl,
  required BigInt timeoutMs,
}) => RustLib.instance.api.crateApiTestAllProxiesLatency(
  testUrl: testUrl,
  timeoutMs: timeoutMs,
);

Future<List<RuleDto>> getRules() => RustLib.instance.api.crateApiGetRules();

Future<DnsConfigDto> getDnsConfig() =>
    RustLib.instance.api.crateApiGetDnsConfig();

Future<void> setProxyMode({required int mode}) =>
    RustLib.instance.api.crateApiSetProxyMode(mode: mode);

Future<int> getProxyMode() => RustLib.instance.api.crateApiGetProxyMode();

Future<void> setVpnFd({required int fd}) =>
    RustLib.instance.api.crateApiSetVpnFd(fd: fd);

Future<void> clearVpnFd() => RustLib.instance.api.crateApiClearVpnFd();

Future<void> setProtectSocketCallbackEnabled({required bool enabled}) => RustLib
    .instance
    .api
    .crateApiSetProtectSocketCallbackEnabled(enabled: enabled);

Future<void> startTunMode({
  required String tunName,
  required String tunAddress,
  required String tunNetmask,
}) => RustLib.instance.api.crateApiStartTunMode(
  tunName: tunName,
  tunAddress: tunAddress,
  tunNetmask: tunNetmask,
);

Future<void> stopTunMode() => RustLib.instance.api.crateApiStopTunMode();

Future<void> initializeVeloguard({required String configJson}) =>
    RustLib.instance.api.crateApiInitializeVeloguard(configJson: configJson);

Future<void> startVeloguard() => RustLib.instance.api.crateApiStartVeloguard();

Future<void> stopVeloguard() => RustLib.instance.api.crateApiStopVeloguard();

Future<void> reloadVeloguard({required String configJson}) =>
    RustLib.instance.api.crateApiReloadVeloguard(configJson: configJson);

Future<ProxyStatus> getVeloguardStatus() =>
    RustLib.instance.api.crateApiGetVeloguardStatus();

Future<TrafficStats> getTrafficStats() =>
    RustLib.instance.api.crateApiGetTrafficStats();

Future<bool> testConfig({required String configJson}) =>
    RustLib.instance.api.crateApiTestConfig(configJson: configJson);

Future<List<ConnectionInfo>> getConnections() =>
    RustLib.instance.api.crateApiGetConnections();

Future<void> closeConnection({required String connectionId}) =>
    RustLib.instance.api.crateApiCloseConnection(connectionId: connectionId);

Future<List<String>> getLogs({int? lines}) =>
    RustLib.instance.api.crateApiGetLogs(lines: lines);

Future<void> setLogLevel({required String level}) =>
    RustLib.instance.api.crateApiSetLogLevel(level: level);

Future<SystemInfo> getSystemInfo() =>
    RustLib.instance.api.crateApiGetSystemInfo();

Future<String> getVersion() => RustLib.instance.api.crateApiGetVersion();

/// Get build information
Future<String> getBuildInfo() => RustLib.instance.api.crateApiGetBuildInfo();

Future<LatencyTestResult> testProxyLatency({
  required String server,
  required int port,
  required int timeoutMs,
}) => RustLib.instance.api.crateApiTestProxyLatency(
  server: server,
  port: port,
  timeoutMs: timeoutMs,
);

Future<LatencyTestResult> testOutboundLatency({
  required String outboundName,
  required int timeoutMs,
}) => RustLib.instance.api.crateApiTestOutboundLatency(
  outboundName: outboundName,
  timeoutMs: timeoutMs,
);

Future<LatencyTestResult> testTcpConnectivity({
  required String server,
  required int port,
  required int timeoutMs,
}) => RustLib.instance.api.crateApiTestTcpConnectivity(
  server: server,
  port: port,
  timeoutMs: timeoutMs,
);

Future<LatencyTestResult> testShadowsocksLatency({
  required String server,
  required int port,
  required String password,
  required String cipher,
  required int timeoutMs,
}) => RustLib.instance.api.crateApiTestShadowsocksLatency(
  server: server,
  port: port,
  password: password,
  cipher: cipher,
  timeoutMs: timeoutMs,
);

Future<List<LatencyTestResult>> testProxiesLatency({
  required List<(String, int)> proxies,
  required int timeoutMs,
}) => RustLib.instance.api.crateApiTestProxiesLatency(
  proxies: proxies,
  timeoutMs: timeoutMs,
);

Future<bool> selectProxyInGroup({
  required String groupName,
  required String proxyName,
}) => RustLib.instance.api.crateApiSelectProxyInGroup(
  groupName: groupName,
  proxyName: proxyName,
);

Future<String?> getSelectedProxyInGroup({required String groupName}) =>
    RustLib.instance.api.crateApiGetSelectedProxyInGroup(groupName: groupName);

Future<List<ActiveConnection>> getActiveConnections() =>
    RustLib.instance.api.crateApiGetActiveConnections();

Future<bool> closeActiveConnection({required String connectionId}) => RustLib
    .instance
    .api
    .crateApiCloseActiveConnection(connectionId: connectionId);

Future<void> closeAllConnections() =>
    RustLib.instance.api.crateApiCloseAllConnections();

Future<(BigInt, BigInt, BigInt, BigInt)> getConnectionStats() =>
    RustLib.instance.api.crateApiGetConnectionStats();

Future<bool> isWintunAvailable() =>
    RustLib.instance.api.crateApiIsWintunAvailable();

Future<String?> getWintunDllPath() =>
    RustLib.instance.api.crateApiGetWintunDllPath();

Future<String> ensureWintunDll() =>
    RustLib.instance.api.crateApiEnsureWintunDll();

Future<TunStatus> enableTunMode() =>
    RustLib.instance.api.crateApiEnableTunMode();

Future<TunStatus> enableTunModeWithMode({required String mode}) =>
    RustLib.instance.api.crateApiEnableTunModeWithMode(mode: mode);

Future<TunStatus> disableTunMode() =>
    RustLib.instance.api.crateApiDisableTunMode();

Future<TunStatus> getTunStatus() => RustLib.instance.api.crateApiGetTunStatus();

Future<bool> setWindowsProxyMode({required String mode}) =>
    RustLib.instance.api.crateApiSetWindowsProxyMode(mode: mode);

Future<String> getWindowsProxyModeStr() =>
    RustLib.instance.api.crateApiGetWindowsProxyModeStr();

Future<(BigInt, BigInt, BigInt, BigInt, BigInt, BigInt)> getWindowsTunStats() =>
    RustLib.instance.api.crateApiGetWindowsTunStats();

Future<bool> enableUwpLoopback() =>
    RustLib.instance.api.crateApiEnableUwpLoopback();

Future<bool> openUwpLoopbackUtility() =>
    RustLib.instance.api.crateApiOpenUwpLoopbackUtility();

Future<void> setAndroidVpnFd({required int fd}) =>
    RustLib.instance.api.crateApiSetAndroidVpnFd(fd: fd);

Future<int> getAndroidVpnFd() => RustLib.instance.api.crateApiGetAndroidVpnFd();

Future<void> clearAndroidVpnFd() =>
    RustLib.instance.api.crateApiClearAndroidVpnFd();

Future<void> setAndroidProxyMode({required String mode}) =>
    RustLib.instance.api.crateApiSetAndroidProxyMode(mode: mode);

Future<String> getAndroidProxyMode() =>
    RustLib.instance.api.crateApiGetAndroidProxyMode();

Future<bool> startAndroidVpn() =>
    RustLib.instance.api.crateApiStartAndroidVpn();

Future<bool> stopAndroidVpn() => RustLib.instance.api.crateApiStopAndroidVpn();
