// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: unused_import, unused_element, unnecessary_import, duplicate_ignore, invalid_use_of_internal_member, annotate_overrides, non_constant_identifier_names, curly_braces_in_flow_control_structures, prefer_const_literals_to_create_immutables, unused_field

import 'api.dart';
import 'dart:async';
import 'dart:convert';
import 'frb_generated.dart';
import 'frb_generated.io.dart'
    if (dart.library.js_interop) 'frb_generated.web.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'types.dart';

/// Main entrypoint of the Rust API
class RustLib extends BaseEntrypoint<RustLibApi, RustLibApiImpl, RustLibWire> {
  @internal
  static final instance = RustLib._();

  RustLib._();

  /// Initialize flutter_rust_bridge
  static Future<void> init({
    RustLibApi? api,
    BaseHandler? handler,
    ExternalLibrary? externalLibrary,
    bool forceSameCodegenVersion = true,
  }) async {
    await instance.initImpl(
      api: api,
      handler: handler,
      externalLibrary: externalLibrary,
      forceSameCodegenVersion: forceSameCodegenVersion,
    );
  }

  /// Initialize flutter_rust_bridge in mock mode.
  /// No libraries for FFI are loaded.
  static void initMock({required RustLibApi api}) {
    instance.initMockImpl(api: api);
  }

  /// Dispose flutter_rust_bridge
  ///
  /// The call to this function is optional, since flutter_rust_bridge (and everything else)
  /// is automatically disposed when the app stops.
  static void dispose() => instance.disposeImpl();

  @override
  ApiImplConstructor<RustLibApiImpl, RustLibWire> get apiImplConstructor =>
      RustLibApiImpl.new;

  @override
  WireConstructor<RustLibWire> get wireConstructor =>
      RustLibWire.fromExternalLibrary;

  @override
  Future<void> executeRustInitializers() async {
    await api.crateApiInitApp();
  }

  @override
  ExternalLibraryLoaderConfig get defaultExternalLibraryLoaderConfig =>
      kDefaultExternalLibraryLoaderConfig;

  @override
  String get codegenVersion => '2.11.1';

  @override
  int get rustContentHash => 1477366539;

  static const kDefaultExternalLibraryLoaderConfig =
      ExternalLibraryLoaderConfig(
        stem: 'rust_lib_veloguard',
        ioDirectory: 'rust/veloguard-lib/target/release/',
        webPrefix: 'pkg/',
      );
}

abstract class RustLibApi extends BaseApi {
  Future<void> crateApiClearAndroidVpnFd();

  Future<void> crateApiClearVpnFd();

  Future<bool> crateApiCloseActiveConnection({required String connectionId});

  Future<void> crateApiCloseAllConnections();

  Future<void> crateApiCloseAllConnectionsDto();

  Future<void> crateApiCloseConnection({required String connectionId});

  Future<void> crateApiCloseConnectionById({required String id});

  Future<TunStatus> crateApiDisableTunMode();

  Future<TunStatus> crateApiEnableTunMode();

  Future<TunStatus> crateApiEnableTunModeWithMode({required String mode});

  Future<bool> crateApiEnableUwpLoopback();

  Future<String> crateApiEnsureWintunDll();

  Future<List<ActiveConnection>> crateApiGetActiveConnections();

  Future<String> crateApiGetAndroidProxyMode();

  Future<int> crateApiGetAndroidVpnFd();

  Future<String> crateApiGetBuildInfo();

  Future<(BigInt, BigInt, BigInt, BigInt)> crateApiGetConnectionStats();

  Future<List<ConnectionInfo>> crateApiGetConnections();

  Future<List<ConnectionDto>> crateApiGetConnectionsDto();

  Future<DnsConfigDto> crateApiGetDnsConfig();

  Future<List<String>> crateApiGetLogs({int? lines});

  Future<List<ProxyInfoDto>> crateApiGetProxies();

  Future<List<ProxyGroupDto>> crateApiGetProxyGroups();

  Future<int> crateApiGetProxyMode();

  Future<List<RuleDto>> crateApiGetRules();

  Future<String?> crateApiGetSelectedProxyInGroup({required String groupName});

  Future<SystemInfo> crateApiGetSystemInfo();

  Future<TrafficStats> crateApiGetTrafficStats();

  Future<TrafficStatsDto> crateApiGetTrafficStatsDto();

  Future<TunStatus> crateApiGetTunStatus();

  Future<ProxyStatus> crateApiGetVeloguardStatus();

  Future<String> crateApiGetVersion();

  Future<String> crateApiGetWindowsProxyModeStr();

  Future<(BigInt, BigInt, BigInt, BigInt, BigInt, BigInt)>
  crateApiGetWindowsTunStats();

  Future<String?> crateApiGetWintunDllPath();

  Future<void> crateApiInitApp();

  Future<void> crateApiInitializeVeloguard({required String configJson});

  Future<bool> crateApiIsProxyRunning();

  Future<bool> crateApiIsWintunAvailable();

  Future<bool> crateApiOpenUwpLoopbackUtility();

  Future<void> crateApiReloadConfigFromFile({required String configPath});

  Future<void> crateApiReloadConfigFromYaml({required String yamlConfig});

  Future<void> crateApiReloadVeloguard({required String configJson});

  Future<void> crateApiSelectProxy({
    required String groupTag,
    required String proxyTag,
  });

  Future<bool> crateApiSelectProxyInGroup({
    required String groupName,
    required String proxyName,
  });

  Future<void> crateApiSetAndroidProxyMode({required String mode});

  Future<void> crateApiSetAndroidVpnFd({required int fd});

  Future<void> crateApiSetLogLevel({required String level});

  Future<void> crateApiSetProtectSocketCallbackEnabled({required bool enabled});

  Future<void> crateApiSetProxyMode({required int mode});

  Future<void> crateApiSetVpnFd({required int fd});

  Future<bool> crateApiSetWindowsProxyMode({required String mode});

  Future<bool> crateApiStartAndroidVpn();

  Future<void> crateApiStartProxyFromFile({required String configPath});

  Future<void> crateApiStartProxyFromYaml({required String yamlConfig});

  Future<void> crateApiStartTunMode({
    required String tunName,
    required String tunAddress,
    required String tunNetmask,
  });

  Future<void> crateApiStartVeloguard();

  Future<bool> crateApiStopAndroidVpn();

  Future<void> crateApiStopProxy();

  Future<void> crateApiStopTunMode();

  Future<void> crateApiStopVeloguard();

  Future<List<ProxyLatencyDto>> crateApiTestAllProxiesLatency({
    required String testUrl,
    required BigInt timeoutMs,
  });

  Future<bool> crateApiTestConfig({required String configJson});

  Future<LatencyTestResult> crateApiTestOutboundLatency({
    required String outboundName,
    required int timeoutMs,
  });

  Future<List<LatencyTestResult>> crateApiTestProxiesLatency({
    required List<(String, int)> proxies,
    required int timeoutMs,
  });

  Future<LatencyTestResult> crateApiTestProxyLatency({
    required String server,
    required int port,
    required int timeoutMs,
  });

  Future<BigInt> crateApiTestProxyLatencyDto({
    required String tag,
    required String testUrl,
    required BigInt timeoutMs,
  });

  Future<LatencyTestResult> crateApiTestShadowsocksLatency({
    required String server,
    required int port,
    required String password,
    required String cipher,
    required int timeoutMs,
  });

  Future<LatencyTestResult> crateApiTestTcpConnectivity({
    required String server,
    required int port,
    required int timeoutMs,
  });
}

class RustLibApiImpl extends RustLibApiImplPlatform implements RustLibApi {
  RustLibApiImpl({
    required super.handler,
    required super.wire,
    required super.generalizedFrbRustBinding,
    required super.portManager,
  });

  @override
  Future<void> crateApiClearAndroidVpnFd() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          return wire.wire__crate__api__clear_android_vpn_fd(port_);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_unit,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiClearAndroidVpnFdConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiClearAndroidVpnFdConstMeta =>
      const TaskConstMeta(debugName: "clear_android_vpn_fd", argNames: []);

  @override
  Future<void> crateApiClearVpnFd() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          return wire.wire__crate__api__clear_vpn_fd(port_);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_unit,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiClearVpnFdConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiClearVpnFdConstMeta =>
      const TaskConstMeta(debugName: "clear_vpn_fd", argNames: []);

  @override
  Future<bool> crateApiCloseActiveConnection({required String connectionId}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          var arg0 = cst_encode_String(connectionId);
          return wire.wire__crate__api__close_active_connection(port_, arg0);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_bool,
          decodeErrorData: dco_decode_AnyhowException,
        ),
        constMeta: kCrateApiCloseActiveConnectionConstMeta,
        argValues: [connectionId],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiCloseActiveConnectionConstMeta =>
      const TaskConstMeta(
        debugName: "close_active_connection",
        argNames: ["connectionId"],
      );

  @override
  Future<void> crateApiCloseAllConnections() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          return wire.wire__crate__api__close_all_connections(port_);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_unit,
          decodeErrorData: dco_decode_AnyhowException,
        ),
        constMeta: kCrateApiCloseAllConnectionsConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiCloseAllConnectionsConstMeta =>
      const TaskConstMeta(debugName: "close_all_connections", argNames: []);

  @override
  Future<void> crateApiCloseAllConnectionsDto() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          return wire.wire__crate__api__close_all_connections_dto(port_);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_unit,
          decodeErrorData: dco_decode_String,
        ),
        constMeta: kCrateApiCloseAllConnectionsDtoConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiCloseAllConnectionsDtoConstMeta =>
      const TaskConstMeta(debugName: "close_all_connections_dto", argNames: []);

  @override
  Future<void> crateApiCloseConnection({required String connectionId}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          var arg0 = cst_encode_String(connectionId);
          return wire.wire__crate__api__close_connection(port_, arg0);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_unit,
          decodeErrorData: dco_decode_AnyhowException,
        ),
        constMeta: kCrateApiCloseConnectionConstMeta,
        argValues: [connectionId],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiCloseConnectionConstMeta => const TaskConstMeta(
    debugName: "close_connection",
    argNames: ["connectionId"],
  );

  @override
  Future<void> crateApiCloseConnectionById({required String id}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          var arg0 = cst_encode_String(id);
          return wire.wire__crate__api__close_connection_by_id(port_, arg0);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_unit,
          decodeErrorData: dco_decode_String,
        ),
        constMeta: kCrateApiCloseConnectionByIdConstMeta,
        argValues: [id],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiCloseConnectionByIdConstMeta =>
      const TaskConstMeta(
        debugName: "close_connection_by_id",
        argNames: ["id"],
      );

  @override
  Future<TunStatus> crateApiDisableTunMode() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          return wire.wire__crate__api__disable_tun_mode(port_);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_tun_status,
          decodeErrorData: dco_decode_AnyhowException,
        ),
        constMeta: kCrateApiDisableTunModeConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiDisableTunModeConstMeta =>
      const TaskConstMeta(debugName: "disable_tun_mode", argNames: []);

  @override
  Future<TunStatus> crateApiEnableTunMode() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          return wire.wire__crate__api__enable_tun_mode(port_);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_tun_status,
          decodeErrorData: dco_decode_AnyhowException,
        ),
        constMeta: kCrateApiEnableTunModeConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiEnableTunModeConstMeta =>
      const TaskConstMeta(debugName: "enable_tun_mode", argNames: []);

  @override
  Future<TunStatus> crateApiEnableTunModeWithMode({required String mode}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          var arg0 = cst_encode_String(mode);
          return wire.wire__crate__api__enable_tun_mode_with_mode(port_, arg0);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_tun_status,
          decodeErrorData: dco_decode_AnyhowException,
        ),
        constMeta: kCrateApiEnableTunModeWithModeConstMeta,
        argValues: [mode],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiEnableTunModeWithModeConstMeta =>
      const TaskConstMeta(
        debugName: "enable_tun_mode_with_mode",
        argNames: ["mode"],
      );

  @override
  Future<bool> crateApiEnableUwpLoopback() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          return wire.wire__crate__api__enable_uwp_loopback(port_);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_bool,
          decodeErrorData: dco_decode_AnyhowException,
        ),
        constMeta: kCrateApiEnableUwpLoopbackConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiEnableUwpLoopbackConstMeta =>
      const TaskConstMeta(debugName: "enable_uwp_loopback", argNames: []);

  @override
  Future<String> crateApiEnsureWintunDll() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          return wire.wire__crate__api__ensure_wintun_dll(port_);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_String,
          decodeErrorData: dco_decode_AnyhowException,
        ),
        constMeta: kCrateApiEnsureWintunDllConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiEnsureWintunDllConstMeta =>
      const TaskConstMeta(debugName: "ensure_wintun_dll", argNames: []);

  @override
  Future<List<ActiveConnection>> crateApiGetActiveConnections() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          return wire.wire__crate__api__get_active_connections(port_);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_list_active_connection,
          decodeErrorData: dco_decode_AnyhowException,
        ),
        constMeta: kCrateApiGetActiveConnectionsConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiGetActiveConnectionsConstMeta =>
      const TaskConstMeta(debugName: "get_active_connections", argNames: []);

  @override
  Future<String> crateApiGetAndroidProxyMode() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          return wire.wire__crate__api__get_android_proxy_mode(port_);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_String,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiGetAndroidProxyModeConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiGetAndroidProxyModeConstMeta =>
      const TaskConstMeta(debugName: "get_android_proxy_mode", argNames: []);

  @override
  Future<int> crateApiGetAndroidVpnFd() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          return wire.wire__crate__api__get_android_vpn_fd(port_);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_i_32,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiGetAndroidVpnFdConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiGetAndroidVpnFdConstMeta =>
      const TaskConstMeta(debugName: "get_android_vpn_fd", argNames: []);

  @override
  Future<String> crateApiGetBuildInfo() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          return wire.wire__crate__api__get_build_info(port_);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_String,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiGetBuildInfoConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiGetBuildInfoConstMeta =>
      const TaskConstMeta(debugName: "get_build_info", argNames: []);

  @override
  Future<(BigInt, BigInt, BigInt, BigInt)> crateApiGetConnectionStats() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          return wire.wire__crate__api__get_connection_stats(port_);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_record_u_64_u_64_u_64_u_64,
          decodeErrorData: dco_decode_AnyhowException,
        ),
        constMeta: kCrateApiGetConnectionStatsConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiGetConnectionStatsConstMeta =>
      const TaskConstMeta(debugName: "get_connection_stats", argNames: []);

  @override
  Future<List<ConnectionInfo>> crateApiGetConnections() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          return wire.wire__crate__api__get_connections(port_);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_list_connection_info,
          decodeErrorData: dco_decode_AnyhowException,
        ),
        constMeta: kCrateApiGetConnectionsConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiGetConnectionsConstMeta =>
      const TaskConstMeta(debugName: "get_connections", argNames: []);

  @override
  Future<List<ConnectionDto>> crateApiGetConnectionsDto() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          return wire.wire__crate__api__get_connections_dto(port_);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_list_connection_dto,
          decodeErrorData: dco_decode_String,
        ),
        constMeta: kCrateApiGetConnectionsDtoConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiGetConnectionsDtoConstMeta =>
      const TaskConstMeta(debugName: "get_connections_dto", argNames: []);

  @override
  Future<DnsConfigDto> crateApiGetDnsConfig() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          return wire.wire__crate__api__get_dns_config(port_);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_dns_config_dto,
          decodeErrorData: dco_decode_String,
        ),
        constMeta: kCrateApiGetDnsConfigConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiGetDnsConfigConstMeta =>
      const TaskConstMeta(debugName: "get_dns_config", argNames: []);

  @override
  Future<List<String>> crateApiGetLogs({int? lines}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          var arg0 = cst_encode_opt_box_autoadd_u_32(lines);
          return wire.wire__crate__api__get_logs(port_, arg0);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_list_String,
          decodeErrorData: dco_decode_AnyhowException,
        ),
        constMeta: kCrateApiGetLogsConstMeta,
        argValues: [lines],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiGetLogsConstMeta =>
      const TaskConstMeta(debugName: "get_logs", argNames: ["lines"]);

  @override
  Future<List<ProxyInfoDto>> crateApiGetProxies() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          return wire.wire__crate__api__get_proxies(port_);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_list_proxy_info_dto,
          decodeErrorData: dco_decode_String,
        ),
        constMeta: kCrateApiGetProxiesConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiGetProxiesConstMeta =>
      const TaskConstMeta(debugName: "get_proxies", argNames: []);

  @override
  Future<List<ProxyGroupDto>> crateApiGetProxyGroups() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          return wire.wire__crate__api__get_proxy_groups(port_);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_list_proxy_group_dto,
          decodeErrorData: dco_decode_String,
        ),
        constMeta: kCrateApiGetProxyGroupsConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiGetProxyGroupsConstMeta =>
      const TaskConstMeta(debugName: "get_proxy_groups", argNames: []);

  @override
  Future<int> crateApiGetProxyMode() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          return wire.wire__crate__api__get_proxy_mode(port_);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_i_32,
          decodeErrorData: dco_decode_String,
        ),
        constMeta: kCrateApiGetProxyModeConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiGetProxyModeConstMeta =>
      const TaskConstMeta(debugName: "get_proxy_mode", argNames: []);

  @override
  Future<List<RuleDto>> crateApiGetRules() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          return wire.wire__crate__api__get_rules(port_);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_list_rule_dto,
          decodeErrorData: dco_decode_String,
        ),
        constMeta: kCrateApiGetRulesConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiGetRulesConstMeta =>
      const TaskConstMeta(debugName: "get_rules", argNames: []);

  @override
  Future<String?> crateApiGetSelectedProxyInGroup({required String groupName}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          var arg0 = cst_encode_String(groupName);
          return wire.wire__crate__api__get_selected_proxy_in_group(
            port_,
            arg0,
          );
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_opt_String,
          decodeErrorData: dco_decode_AnyhowException,
        ),
        constMeta: kCrateApiGetSelectedProxyInGroupConstMeta,
        argValues: [groupName],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiGetSelectedProxyInGroupConstMeta =>
      const TaskConstMeta(
        debugName: "get_selected_proxy_in_group",
        argNames: ["groupName"],
      );

  @override
  Future<SystemInfo> crateApiGetSystemInfo() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          return wire.wire__crate__api__get_system_info(port_);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_system_info,
          decodeErrorData: dco_decode_AnyhowException,
        ),
        constMeta: kCrateApiGetSystemInfoConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiGetSystemInfoConstMeta =>
      const TaskConstMeta(debugName: "get_system_info", argNames: []);

  @override
  Future<TrafficStats> crateApiGetTrafficStats() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          return wire.wire__crate__api__get_traffic_stats(port_);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_traffic_stats,
          decodeErrorData: dco_decode_AnyhowException,
        ),
        constMeta: kCrateApiGetTrafficStatsConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiGetTrafficStatsConstMeta =>
      const TaskConstMeta(debugName: "get_traffic_stats", argNames: []);

  @override
  Future<TrafficStatsDto> crateApiGetTrafficStatsDto() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          return wire.wire__crate__api__get_traffic_stats_dto(port_);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_traffic_stats_dto,
          decodeErrorData: dco_decode_String,
        ),
        constMeta: kCrateApiGetTrafficStatsDtoConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiGetTrafficStatsDtoConstMeta =>
      const TaskConstMeta(debugName: "get_traffic_stats_dto", argNames: []);

  @override
  Future<TunStatus> crateApiGetTunStatus() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          return wire.wire__crate__api__get_tun_status(port_);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_tun_status,
          decodeErrorData: dco_decode_AnyhowException,
        ),
        constMeta: kCrateApiGetTunStatusConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiGetTunStatusConstMeta =>
      const TaskConstMeta(debugName: "get_tun_status", argNames: []);

  @override
  Future<ProxyStatus> crateApiGetVeloguardStatus() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          return wire.wire__crate__api__get_veloguard_status(port_);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_proxy_status,
          decodeErrorData: dco_decode_AnyhowException,
        ),
        constMeta: kCrateApiGetVeloguardStatusConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiGetVeloguardStatusConstMeta =>
      const TaskConstMeta(debugName: "get_veloguard_status", argNames: []);

  @override
  Future<String> crateApiGetVersion() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          return wire.wire__crate__api__get_version(port_);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_String,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiGetVersionConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiGetVersionConstMeta =>
      const TaskConstMeta(debugName: "get_version", argNames: []);

  @override
  Future<String> crateApiGetWindowsProxyModeStr() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          return wire.wire__crate__api__get_windows_proxy_mode_str(port_);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_String,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiGetWindowsProxyModeStrConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiGetWindowsProxyModeStrConstMeta =>
      const TaskConstMeta(
        debugName: "get_windows_proxy_mode_str",
        argNames: [],
      );

  @override
  Future<(BigInt, BigInt, BigInt, BigInt, BigInt, BigInt)>
  crateApiGetWindowsTunStats() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          return wire.wire__crate__api__get_windows_tun_stats(port_);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_record_u_64_u_64_u_64_u_64_usize_usize,
          decodeErrorData: dco_decode_AnyhowException,
        ),
        constMeta: kCrateApiGetWindowsTunStatsConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiGetWindowsTunStatsConstMeta =>
      const TaskConstMeta(debugName: "get_windows_tun_stats", argNames: []);

  @override
  Future<String?> crateApiGetWintunDllPath() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          return wire.wire__crate__api__get_wintun_dll_path(port_);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_opt_String,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiGetWintunDllPathConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiGetWintunDllPathConstMeta =>
      const TaskConstMeta(debugName: "get_wintun_dll_path", argNames: []);

  @override
  Future<void> crateApiInitApp() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          return wire.wire__crate__api__init_app(port_);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_unit,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiInitAppConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiInitAppConstMeta =>
      const TaskConstMeta(debugName: "init_app", argNames: []);

  @override
  Future<void> crateApiInitializeVeloguard({required String configJson}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          var arg0 = cst_encode_String(configJson);
          return wire.wire__crate__api__initialize_veloguard(port_, arg0);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_unit,
          decodeErrorData: dco_decode_AnyhowException,
        ),
        constMeta: kCrateApiInitializeVeloguardConstMeta,
        argValues: [configJson],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiInitializeVeloguardConstMeta =>
      const TaskConstMeta(
        debugName: "initialize_veloguard",
        argNames: ["configJson"],
      );

  @override
  Future<bool> crateApiIsProxyRunning() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          return wire.wire__crate__api__is_proxy_running(port_);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_bool,
          decodeErrorData: dco_decode_String,
        ),
        constMeta: kCrateApiIsProxyRunningConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiIsProxyRunningConstMeta =>
      const TaskConstMeta(debugName: "is_proxy_running", argNames: []);

  @override
  Future<bool> crateApiIsWintunAvailable() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          return wire.wire__crate__api__is_wintun_available(port_);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_bool,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiIsWintunAvailableConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiIsWintunAvailableConstMeta =>
      const TaskConstMeta(debugName: "is_wintun_available", argNames: []);

  @override
  Future<bool> crateApiOpenUwpLoopbackUtility() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          return wire.wire__crate__api__open_uwp_loopback_utility(port_);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_bool,
          decodeErrorData: dco_decode_AnyhowException,
        ),
        constMeta: kCrateApiOpenUwpLoopbackUtilityConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiOpenUwpLoopbackUtilityConstMeta =>
      const TaskConstMeta(debugName: "open_uwp_loopback_utility", argNames: []);

  @override
  Future<void> crateApiReloadConfigFromFile({required String configPath}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          var arg0 = cst_encode_String(configPath);
          return wire.wire__crate__api__reload_config_from_file(port_, arg0);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_unit,
          decodeErrorData: dco_decode_String,
        ),
        constMeta: kCrateApiReloadConfigFromFileConstMeta,
        argValues: [configPath],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiReloadConfigFromFileConstMeta =>
      const TaskConstMeta(
        debugName: "reload_config_from_file",
        argNames: ["configPath"],
      );

  @override
  Future<void> crateApiReloadConfigFromYaml({required String yamlConfig}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          var arg0 = cst_encode_String(yamlConfig);
          return wire.wire__crate__api__reload_config_from_yaml(port_, arg0);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_unit,
          decodeErrorData: dco_decode_String,
        ),
        constMeta: kCrateApiReloadConfigFromYamlConstMeta,
        argValues: [yamlConfig],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiReloadConfigFromYamlConstMeta =>
      const TaskConstMeta(
        debugName: "reload_config_from_yaml",
        argNames: ["yamlConfig"],
      );

  @override
  Future<void> crateApiReloadVeloguard({required String configJson}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          var arg0 = cst_encode_String(configJson);
          return wire.wire__crate__api__reload_veloguard(port_, arg0);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_unit,
          decodeErrorData: dco_decode_AnyhowException,
        ),
        constMeta: kCrateApiReloadVeloguardConstMeta,
        argValues: [configJson],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiReloadVeloguardConstMeta => const TaskConstMeta(
    debugName: "reload_veloguard",
    argNames: ["configJson"],
  );

  @override
  Future<void> crateApiSelectProxy({
    required String groupTag,
    required String proxyTag,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          var arg0 = cst_encode_String(groupTag);
          var arg1 = cst_encode_String(proxyTag);
          return wire.wire__crate__api__select_proxy(port_, arg0, arg1);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_unit,
          decodeErrorData: dco_decode_String,
        ),
        constMeta: kCrateApiSelectProxyConstMeta,
        argValues: [groupTag, proxyTag],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiSelectProxyConstMeta => const TaskConstMeta(
    debugName: "select_proxy",
    argNames: ["groupTag", "proxyTag"],
  );

  @override
  Future<bool> crateApiSelectProxyInGroup({
    required String groupName,
    required String proxyName,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          var arg0 = cst_encode_String(groupName);
          var arg1 = cst_encode_String(proxyName);
          return wire.wire__crate__api__select_proxy_in_group(
            port_,
            arg0,
            arg1,
          );
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_bool,
          decodeErrorData: dco_decode_AnyhowException,
        ),
        constMeta: kCrateApiSelectProxyInGroupConstMeta,
        argValues: [groupName, proxyName],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiSelectProxyInGroupConstMeta => const TaskConstMeta(
    debugName: "select_proxy_in_group",
    argNames: ["groupName", "proxyName"],
  );

  @override
  Future<void> crateApiSetAndroidProxyMode({required String mode}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          var arg0 = cst_encode_String(mode);
          return wire.wire__crate__api__set_android_proxy_mode(port_, arg0);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_unit,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiSetAndroidProxyModeConstMeta,
        argValues: [mode],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiSetAndroidProxyModeConstMeta =>
      const TaskConstMeta(
        debugName: "set_android_proxy_mode",
        argNames: ["mode"],
      );

  @override
  Future<void> crateApiSetAndroidVpnFd({required int fd}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          var arg0 = cst_encode_i_32(fd);
          return wire.wire__crate__api__set_android_vpn_fd(port_, arg0);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_unit,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiSetAndroidVpnFdConstMeta,
        argValues: [fd],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiSetAndroidVpnFdConstMeta =>
      const TaskConstMeta(debugName: "set_android_vpn_fd", argNames: ["fd"]);

  @override
  Future<void> crateApiSetLogLevel({required String level}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          var arg0 = cst_encode_String(level);
          return wire.wire__crate__api__set_log_level(port_, arg0);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_unit,
          decodeErrorData: dco_decode_AnyhowException,
        ),
        constMeta: kCrateApiSetLogLevelConstMeta,
        argValues: [level],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiSetLogLevelConstMeta =>
      const TaskConstMeta(debugName: "set_log_level", argNames: ["level"]);

  @override
  Future<void> crateApiSetProtectSocketCallbackEnabled({
    required bool enabled,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          var arg0 = cst_encode_bool(enabled);
          return wire.wire__crate__api__set_protect_socket_callback_enabled(
            port_,
            arg0,
          );
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_unit,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiSetProtectSocketCallbackEnabledConstMeta,
        argValues: [enabled],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiSetProtectSocketCallbackEnabledConstMeta =>
      const TaskConstMeta(
        debugName: "set_protect_socket_callback_enabled",
        argNames: ["enabled"],
      );

  @override
  Future<void> crateApiSetProxyMode({required int mode}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          var arg0 = cst_encode_i_32(mode);
          return wire.wire__crate__api__set_proxy_mode(port_, arg0);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_unit,
          decodeErrorData: dco_decode_String,
        ),
        constMeta: kCrateApiSetProxyModeConstMeta,
        argValues: [mode],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiSetProxyModeConstMeta =>
      const TaskConstMeta(debugName: "set_proxy_mode", argNames: ["mode"]);

  @override
  Future<void> crateApiSetVpnFd({required int fd}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          var arg0 = cst_encode_i_32(fd);
          return wire.wire__crate__api__set_vpn_fd(port_, arg0);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_unit,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiSetVpnFdConstMeta,
        argValues: [fd],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiSetVpnFdConstMeta =>
      const TaskConstMeta(debugName: "set_vpn_fd", argNames: ["fd"]);

  @override
  Future<bool> crateApiSetWindowsProxyMode({required String mode}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          var arg0 = cst_encode_String(mode);
          return wire.wire__crate__api__set_windows_proxy_mode(port_, arg0);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_bool,
          decodeErrorData: dco_decode_AnyhowException,
        ),
        constMeta: kCrateApiSetWindowsProxyModeConstMeta,
        argValues: [mode],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiSetWindowsProxyModeConstMeta =>
      const TaskConstMeta(
        debugName: "set_windows_proxy_mode",
        argNames: ["mode"],
      );

  @override
  Future<bool> crateApiStartAndroidVpn() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          return wire.wire__crate__api__start_android_vpn(port_);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_bool,
          decodeErrorData: dco_decode_AnyhowException,
        ),
        constMeta: kCrateApiStartAndroidVpnConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiStartAndroidVpnConstMeta =>
      const TaskConstMeta(debugName: "start_android_vpn", argNames: []);

  @override
  Future<void> crateApiStartProxyFromFile({required String configPath}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          var arg0 = cst_encode_String(configPath);
          return wire.wire__crate__api__start_proxy_from_file(port_, arg0);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_unit,
          decodeErrorData: dco_decode_String,
        ),
        constMeta: kCrateApiStartProxyFromFileConstMeta,
        argValues: [configPath],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiStartProxyFromFileConstMeta => const TaskConstMeta(
    debugName: "start_proxy_from_file",
    argNames: ["configPath"],
  );

  @override
  Future<void> crateApiStartProxyFromYaml({required String yamlConfig}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          var arg0 = cst_encode_String(yamlConfig);
          return wire.wire__crate__api__start_proxy_from_yaml(port_, arg0);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_unit,
          decodeErrorData: dco_decode_String,
        ),
        constMeta: kCrateApiStartProxyFromYamlConstMeta,
        argValues: [yamlConfig],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiStartProxyFromYamlConstMeta => const TaskConstMeta(
    debugName: "start_proxy_from_yaml",
    argNames: ["yamlConfig"],
  );

  @override
  Future<void> crateApiStartTunMode({
    required String tunName,
    required String tunAddress,
    required String tunNetmask,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          var arg0 = cst_encode_String(tunName);
          var arg1 = cst_encode_String(tunAddress);
          var arg2 = cst_encode_String(tunNetmask);
          return wire.wire__crate__api__start_tun_mode(port_, arg0, arg1, arg2);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_unit,
          decodeErrorData: dco_decode_String,
        ),
        constMeta: kCrateApiStartTunModeConstMeta,
        argValues: [tunName, tunAddress, tunNetmask],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiStartTunModeConstMeta => const TaskConstMeta(
    debugName: "start_tun_mode",
    argNames: ["tunName", "tunAddress", "tunNetmask"],
  );

  @override
  Future<void> crateApiStartVeloguard() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          return wire.wire__crate__api__start_veloguard(port_);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_unit,
          decodeErrorData: dco_decode_AnyhowException,
        ),
        constMeta: kCrateApiStartVeloguardConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiStartVeloguardConstMeta =>
      const TaskConstMeta(debugName: "start_veloguard", argNames: []);

  @override
  Future<bool> crateApiStopAndroidVpn() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          return wire.wire__crate__api__stop_android_vpn(port_);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_bool,
          decodeErrorData: dco_decode_AnyhowException,
        ),
        constMeta: kCrateApiStopAndroidVpnConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiStopAndroidVpnConstMeta =>
      const TaskConstMeta(debugName: "stop_android_vpn", argNames: []);

  @override
  Future<void> crateApiStopProxy() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          return wire.wire__crate__api__stop_proxy(port_);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_unit,
          decodeErrorData: dco_decode_String,
        ),
        constMeta: kCrateApiStopProxyConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiStopProxyConstMeta =>
      const TaskConstMeta(debugName: "stop_proxy", argNames: []);

  @override
  Future<void> crateApiStopTunMode() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          return wire.wire__crate__api__stop_tun_mode(port_);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_unit,
          decodeErrorData: dco_decode_String,
        ),
        constMeta: kCrateApiStopTunModeConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiStopTunModeConstMeta =>
      const TaskConstMeta(debugName: "stop_tun_mode", argNames: []);

  @override
  Future<void> crateApiStopVeloguard() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          return wire.wire__crate__api__stop_veloguard(port_);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_unit,
          decodeErrorData: dco_decode_AnyhowException,
        ),
        constMeta: kCrateApiStopVeloguardConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiStopVeloguardConstMeta =>
      const TaskConstMeta(debugName: "stop_veloguard", argNames: []);

  @override
  Future<List<ProxyLatencyDto>> crateApiTestAllProxiesLatency({
    required String testUrl,
    required BigInt timeoutMs,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          var arg0 = cst_encode_String(testUrl);
          var arg1 = cst_encode_u_64(timeoutMs);
          return wire.wire__crate__api__test_all_proxies_latency(
            port_,
            arg0,
            arg1,
          );
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_list_proxy_latency_dto,
          decodeErrorData: dco_decode_String,
        ),
        constMeta: kCrateApiTestAllProxiesLatencyConstMeta,
        argValues: [testUrl, timeoutMs],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiTestAllProxiesLatencyConstMeta =>
      const TaskConstMeta(
        debugName: "test_all_proxies_latency",
        argNames: ["testUrl", "timeoutMs"],
      );

  @override
  Future<bool> crateApiTestConfig({required String configJson}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          var arg0 = cst_encode_String(configJson);
          return wire.wire__crate__api__test_config(port_, arg0);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_bool,
          decodeErrorData: dco_decode_AnyhowException,
        ),
        constMeta: kCrateApiTestConfigConstMeta,
        argValues: [configJson],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiTestConfigConstMeta =>
      const TaskConstMeta(debugName: "test_config", argNames: ["configJson"]);

  @override
  Future<LatencyTestResult> crateApiTestOutboundLatency({
    required String outboundName,
    required int timeoutMs,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          var arg0 = cst_encode_String(outboundName);
          var arg1 = cst_encode_u_32(timeoutMs);
          return wire.wire__crate__api__test_outbound_latency(
            port_,
            arg0,
            arg1,
          );
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_latency_test_result,
          decodeErrorData: dco_decode_AnyhowException,
        ),
        constMeta: kCrateApiTestOutboundLatencyConstMeta,
        argValues: [outboundName, timeoutMs],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiTestOutboundLatencyConstMeta =>
      const TaskConstMeta(
        debugName: "test_outbound_latency",
        argNames: ["outboundName", "timeoutMs"],
      );

  @override
  Future<List<LatencyTestResult>> crateApiTestProxiesLatency({
    required List<(String, int)> proxies,
    required int timeoutMs,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          var arg0 = cst_encode_list_record_string_u_16(proxies);
          var arg1 = cst_encode_u_32(timeoutMs);
          return wire.wire__crate__api__test_proxies_latency(port_, arg0, arg1);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_list_latency_test_result,
          decodeErrorData: dco_decode_AnyhowException,
        ),
        constMeta: kCrateApiTestProxiesLatencyConstMeta,
        argValues: [proxies, timeoutMs],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiTestProxiesLatencyConstMeta => const TaskConstMeta(
    debugName: "test_proxies_latency",
    argNames: ["proxies", "timeoutMs"],
  );

  @override
  Future<LatencyTestResult> crateApiTestProxyLatency({
    required String server,
    required int port,
    required int timeoutMs,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          var arg0 = cst_encode_String(server);
          var arg1 = cst_encode_u_16(port);
          var arg2 = cst_encode_u_32(timeoutMs);
          return wire.wire__crate__api__test_proxy_latency(
            port_,
            arg0,
            arg1,
            arg2,
          );
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_latency_test_result,
          decodeErrorData: dco_decode_AnyhowException,
        ),
        constMeta: kCrateApiTestProxyLatencyConstMeta,
        argValues: [server, port, timeoutMs],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiTestProxyLatencyConstMeta => const TaskConstMeta(
    debugName: "test_proxy_latency",
    argNames: ["server", "port", "timeoutMs"],
  );

  @override
  Future<BigInt> crateApiTestProxyLatencyDto({
    required String tag,
    required String testUrl,
    required BigInt timeoutMs,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          var arg0 = cst_encode_String(tag);
          var arg1 = cst_encode_String(testUrl);
          var arg2 = cst_encode_u_64(timeoutMs);
          return wire.wire__crate__api__test_proxy_latency_dto(
            port_,
            arg0,
            arg1,
            arg2,
          );
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_u_64,
          decodeErrorData: dco_decode_String,
        ),
        constMeta: kCrateApiTestProxyLatencyDtoConstMeta,
        argValues: [tag, testUrl, timeoutMs],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiTestProxyLatencyDtoConstMeta =>
      const TaskConstMeta(
        debugName: "test_proxy_latency_dto",
        argNames: ["tag", "testUrl", "timeoutMs"],
      );

  @override
  Future<LatencyTestResult> crateApiTestShadowsocksLatency({
    required String server,
    required int port,
    required String password,
    required String cipher,
    required int timeoutMs,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          var arg0 = cst_encode_String(server);
          var arg1 = cst_encode_u_16(port);
          var arg2 = cst_encode_String(password);
          var arg3 = cst_encode_String(cipher);
          var arg4 = cst_encode_u_32(timeoutMs);
          return wire.wire__crate__api__test_shadowsocks_latency(
            port_,
            arg0,
            arg1,
            arg2,
            arg3,
            arg4,
          );
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_latency_test_result,
          decodeErrorData: dco_decode_AnyhowException,
        ),
        constMeta: kCrateApiTestShadowsocksLatencyConstMeta,
        argValues: [server, port, password, cipher, timeoutMs],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiTestShadowsocksLatencyConstMeta =>
      const TaskConstMeta(
        debugName: "test_shadowsocks_latency",
        argNames: ["server", "port", "password", "cipher", "timeoutMs"],
      );

  @override
  Future<LatencyTestResult> crateApiTestTcpConnectivity({
    required String server,
    required int port,
    required int timeoutMs,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          var arg0 = cst_encode_String(server);
          var arg1 = cst_encode_u_16(port);
          var arg2 = cst_encode_u_32(timeoutMs);
          return wire.wire__crate__api__test_tcp_connectivity(
            port_,
            arg0,
            arg1,
            arg2,
          );
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_latency_test_result,
          decodeErrorData: dco_decode_AnyhowException,
        ),
        constMeta: kCrateApiTestTcpConnectivityConstMeta,
        argValues: [server, port, timeoutMs],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiTestTcpConnectivityConstMeta =>
      const TaskConstMeta(
        debugName: "test_tcp_connectivity",
        argNames: ["server", "port", "timeoutMs"],
      );

  @protected
  AnyhowException dco_decode_AnyhowException(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return AnyhowException(raw as String);
  }

  @protected
  String dco_decode_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as String;
  }

  @protected
  ActiveConnection dco_decode_active_connection(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 14)
      throw Exception('unexpected arr length: expect 14 but see ${arr.length}');
    return ActiveConnection(
      id: dco_decode_String(arr[0]),
      inboundTag: dco_decode_String(arr[1]),
      outboundTag: dco_decode_String(arr[2]),
      host: dco_decode_String(arr[3]),
      destinationIp: dco_decode_opt_String(arr[4]),
      destinationPort: dco_decode_u_16(arr[5]),
      protocol: dco_decode_String(arr[6]),
      network: dco_decode_String(arr[7]),
      uploadBytes: dco_decode_u_64(arr[8]),
      downloadBytes: dco_decode_u_64(arr[9]),
      startTime: dco_decode_u_64(arr[10]),
      rule: dco_decode_String(arr[11]),
      rulePayload: dco_decode_String(arr[12]),
      processName: dco_decode_opt_String(arr[13]),
    );
  }

  @protected
  bool dco_decode_bool(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as bool;
  }

  @protected
  int dco_decode_box_autoadd_u_16(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  int dco_decode_box_autoadd_u_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  BigInt dco_decode_box_autoadd_u_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_u_64(raw);
  }

  @protected
  ConnectionDto dco_decode_connection_dto(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 10)
      throw Exception('unexpected arr length: expect 10 but see ${arr.length}');
    return ConnectionDto(
      id: dco_decode_String(arr[0]),
      srcAddr: dco_decode_String(arr[1]),
      dstAddr: dco_decode_String(arr[2]),
      dstDomain: dco_decode_opt_String(arr[3]),
      protocol: dco_decode_String(arr[4]),
      outbound: dco_decode_String(arr[5]),
      upload: dco_decode_u_64(arr[6]),
      download: dco_decode_u_64(arr[7]),
      startTime: dco_decode_i_64(arr[8]),
      rule: dco_decode_opt_String(arr[9]),
    );
  }

  @protected
  ConnectionInfo dco_decode_connection_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 8)
      throw Exception('unexpected arr length: expect 8 but see ${arr.length}');
    return ConnectionInfo(
      id: dco_decode_String(arr[0]),
      host: dco_decode_String(arr[1]),
      destination: dco_decode_String(arr[2]),
      upload: dco_decode_u_64(arr[3]),
      download: dco_decode_u_64(arr[4]),
      startTime: dco_decode_u_64(arr[5]),
      rule: dco_decode_String(arr[6]),
      chains: dco_decode_list_String(arr[7]),
    );
  }

  @protected
  DnsConfigDto dco_decode_dns_config_dto(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 5)
      throw Exception('unexpected arr length: expect 5 but see ${arr.length}');
    return DnsConfigDto(
      enable: dco_decode_bool(arr[0]),
      listen: dco_decode_String(arr[1]),
      enhancedMode: dco_decode_String(arr[2]),
      nameservers: dco_decode_list_String(arr[3]),
      fallback: dco_decode_list_String(arr[4]),
    );
  }

  @protected
  double dco_decode_f_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as double;
  }

  @protected
  int dco_decode_i_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  PlatformInt64 dco_decode_i_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dcoDecodeI64(raw);
  }

  @protected
  LatencyTestResult dco_decode_latency_test_result(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4)
      throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return LatencyTestResult(
      proxyName: dco_decode_String(arr[0]),
      latencyMs: dco_decode_opt_box_autoadd_u_32(arr[1]),
      success: dco_decode_bool(arr[2]),
      error: dco_decode_opt_String(arr[3]),
    );
  }

  @protected
  List<String> dco_decode_list_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_String).toList();
  }

  @protected
  List<ActiveConnection> dco_decode_list_active_connection(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_active_connection).toList();
  }

  @protected
  List<ConnectionDto> dco_decode_list_connection_dto(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_connection_dto).toList();
  }

  @protected
  List<ConnectionInfo> dco_decode_list_connection_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_connection_info).toList();
  }

  @protected
  List<LatencyTestResult> dco_decode_list_latency_test_result(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_latency_test_result).toList();
  }

  @protected
  Uint8List dco_decode_list_prim_u_8_strict(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as Uint8List;
  }

  @protected
  List<ProxyGroupDto> dco_decode_list_proxy_group_dto(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_proxy_group_dto).toList();
  }

  @protected
  List<ProxyInfoDto> dco_decode_list_proxy_info_dto(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_proxy_info_dto).toList();
  }

  @protected
  List<ProxyLatencyDto> dco_decode_list_proxy_latency_dto(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_proxy_latency_dto).toList();
  }

  @protected
  List<(String, int)> dco_decode_list_record_string_u_16(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_record_string_u_16).toList();
  }

  @protected
  List<RuleDto> dco_decode_list_rule_dto(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_rule_dto).toList();
  }

  @protected
  String? dco_decode_opt_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_String(raw);
  }

  @protected
  int? dco_decode_opt_box_autoadd_u_16(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_u_16(raw);
  }

  @protected
  int? dco_decode_opt_box_autoadd_u_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_u_32(raw);
  }

  @protected
  BigInt? dco_decode_opt_box_autoadd_u_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_u_64(raw);
  }

  @protected
  ProxyGroupDto dco_decode_proxy_group_dto(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4)
      throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return ProxyGroupDto(
      tag: dco_decode_String(arr[0]),
      groupType: dco_decode_String(arr[1]),
      proxies: dco_decode_list_String(arr[2]),
      selected: dco_decode_String(arr[3]),
    );
  }

  @protected
  ProxyInfoDto dco_decode_proxy_info_dto(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 6)
      throw Exception('unexpected arr length: expect 6 but see ${arr.length}');
    return ProxyInfoDto(
      tag: dco_decode_String(arr[0]),
      protocolType: dco_decode_String(arr[1]),
      server: dco_decode_opt_String(arr[2]),
      port: dco_decode_opt_box_autoadd_u_16(arr[3]),
      latencyMs: dco_decode_opt_box_autoadd_u_64(arr[4]),
      alive: dco_decode_bool(arr[5]),
    );
  }

  @protected
  ProxyLatencyDto dco_decode_proxy_latency_dto(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return ProxyLatencyDto(
      tag: dco_decode_String(arr[0]),
      latencyMs: dco_decode_opt_box_autoadd_u_64(arr[1]),
      error: dco_decode_opt_String(arr[2]),
    );
  }

  @protected
  ProxyStatus dco_decode_proxy_status(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 6)
      throw Exception('unexpected arr length: expect 6 but see ${arr.length}');
    return ProxyStatus(
      running: dco_decode_bool(arr[0]),
      inboundCount: dco_decode_u_32(arr[1]),
      outboundCount: dco_decode_u_32(arr[2]),
      connectionCount: dco_decode_u_32(arr[3]),
      memoryUsage: dco_decode_u_64(arr[4]),
      uptime: dco_decode_u_64(arr[5]),
    );
  }

  @protected
  (String, int) dco_decode_record_string_u_16(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2) {
      throw Exception('Expected 2 elements, got ${arr.length}');
    }
    return (dco_decode_String(arr[0]), dco_decode_u_16(arr[1]));
  }

  @protected
  (BigInt, BigInt, BigInt, BigInt) dco_decode_record_u_64_u_64_u_64_u_64(
    dynamic raw,
  ) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4) {
      throw Exception('Expected 4 elements, got ${arr.length}');
    }
    return (
      dco_decode_u_64(arr[0]),
      dco_decode_u_64(arr[1]),
      dco_decode_u_64(arr[2]),
      dco_decode_u_64(arr[3]),
    );
  }

  @protected
  (BigInt, BigInt, BigInt, BigInt, BigInt, BigInt)
  dco_decode_record_u_64_u_64_u_64_u_64_usize_usize(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 6) {
      throw Exception('Expected 6 elements, got ${arr.length}');
    }
    return (
      dco_decode_u_64(arr[0]),
      dco_decode_u_64(arr[1]),
      dco_decode_u_64(arr[2]),
      dco_decode_u_64(arr[3]),
      dco_decode_usize(arr[4]),
      dco_decode_usize(arr[5]),
    );
  }

  @protected
  RuleDto dco_decode_rule_dto(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4)
      throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return RuleDto(
      ruleType: dco_decode_String(arr[0]),
      payload: dco_decode_String(arr[1]),
      outbound: dco_decode_String(arr[2]),
      matchedCount: dco_decode_u_64(arr[3]),
    );
  }

  @protected
  SystemInfo dco_decode_system_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 8)
      throw Exception('unexpected arr length: expect 8 but see ${arr.length}');
    return SystemInfo(
      platform: dco_decode_String(arr[0]),
      version: dco_decode_String(arr[1]),
      memoryTotal: dco_decode_u_64(arr[2]),
      memoryUsed: dco_decode_u_64(arr[3]),
      cpuCores: dco_decode_u_32(arr[4]),
      cpuThreads: dco_decode_u_32(arr[5]),
      cpuName: dco_decode_String(arr[6]),
      cpuUsage: dco_decode_f_64(arr[7]),
    );
  }

  @protected
  TrafficStats dco_decode_traffic_stats(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4)
      throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return TrafficStats(
      upload: dco_decode_u_64(arr[0]),
      download: dco_decode_u_64(arr[1]),
      uploadSpeed: dco_decode_u_64(arr[2]),
      downloadSpeed: dco_decode_u_64(arr[3]),
    );
  }

  @protected
  TrafficStatsDto dco_decode_traffic_stats_dto(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 6)
      throw Exception('unexpected arr length: expect 6 but see ${arr.length}');
    return TrafficStatsDto(
      upload: dco_decode_u_64(arr[0]),
      download: dco_decode_u_64(arr[1]),
      totalUpload: dco_decode_u_64(arr[2]),
      totalDownload: dco_decode_u_64(arr[3]),
      connectionCount: dco_decode_u_32(arr[4]),
      uptimeSecs: dco_decode_u_64(arr[5]),
    );
  }

  @protected
  TunStatus dco_decode_tun_status(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4)
      throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return TunStatus(
      enabled: dco_decode_bool(arr[0]),
      interfaceName: dco_decode_opt_String(arr[1]),
      mtu: dco_decode_opt_box_autoadd_u_32(arr[2]),
      error: dco_decode_opt_String(arr[3]),
    );
  }

  @protected
  int dco_decode_u_16(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  int dco_decode_u_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  BigInt dco_decode_u_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dcoDecodeU64(raw);
  }

  @protected
  int dco_decode_u_8(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  void dco_decode_unit(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return;
  }

  @protected
  BigInt dco_decode_usize(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dcoDecodeU64(raw);
  }

  @protected
  AnyhowException sse_decode_AnyhowException(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_String(deserializer);
    return AnyhowException(inner);
  }

  @protected
  String sse_decode_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_list_prim_u_8_strict(deserializer);
    return utf8.decoder.convert(inner);
  }

  @protected
  ActiveConnection sse_decode_active_connection(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_id = sse_decode_String(deserializer);
    var var_inboundTag = sse_decode_String(deserializer);
    var var_outboundTag = sse_decode_String(deserializer);
    var var_host = sse_decode_String(deserializer);
    var var_destinationIp = sse_decode_opt_String(deserializer);
    var var_destinationPort = sse_decode_u_16(deserializer);
    var var_protocol = sse_decode_String(deserializer);
    var var_network = sse_decode_String(deserializer);
    var var_uploadBytes = sse_decode_u_64(deserializer);
    var var_downloadBytes = sse_decode_u_64(deserializer);
    var var_startTime = sse_decode_u_64(deserializer);
    var var_rule = sse_decode_String(deserializer);
    var var_rulePayload = sse_decode_String(deserializer);
    var var_processName = sse_decode_opt_String(deserializer);
    return ActiveConnection(
      id: var_id,
      inboundTag: var_inboundTag,
      outboundTag: var_outboundTag,
      host: var_host,
      destinationIp: var_destinationIp,
      destinationPort: var_destinationPort,
      protocol: var_protocol,
      network: var_network,
      uploadBytes: var_uploadBytes,
      downloadBytes: var_downloadBytes,
      startTime: var_startTime,
      rule: var_rule,
      rulePayload: var_rulePayload,
      processName: var_processName,
    );
  }

  @protected
  bool sse_decode_bool(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint8() != 0;
  }

  @protected
  int sse_decode_box_autoadd_u_16(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_u_16(deserializer));
  }

  @protected
  int sse_decode_box_autoadd_u_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_u_32(deserializer));
  }

  @protected
  BigInt sse_decode_box_autoadd_u_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_u_64(deserializer));
  }

  @protected
  ConnectionDto sse_decode_connection_dto(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_id = sse_decode_String(deserializer);
    var var_srcAddr = sse_decode_String(deserializer);
    var var_dstAddr = sse_decode_String(deserializer);
    var var_dstDomain = sse_decode_opt_String(deserializer);
    var var_protocol = sse_decode_String(deserializer);
    var var_outbound = sse_decode_String(deserializer);
    var var_upload = sse_decode_u_64(deserializer);
    var var_download = sse_decode_u_64(deserializer);
    var var_startTime = sse_decode_i_64(deserializer);
    var var_rule = sse_decode_opt_String(deserializer);
    return ConnectionDto(
      id: var_id,
      srcAddr: var_srcAddr,
      dstAddr: var_dstAddr,
      dstDomain: var_dstDomain,
      protocol: var_protocol,
      outbound: var_outbound,
      upload: var_upload,
      download: var_download,
      startTime: var_startTime,
      rule: var_rule,
    );
  }

  @protected
  ConnectionInfo sse_decode_connection_info(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_id = sse_decode_String(deserializer);
    var var_host = sse_decode_String(deserializer);
    var var_destination = sse_decode_String(deserializer);
    var var_upload = sse_decode_u_64(deserializer);
    var var_download = sse_decode_u_64(deserializer);
    var var_startTime = sse_decode_u_64(deserializer);
    var var_rule = sse_decode_String(deserializer);
    var var_chains = sse_decode_list_String(deserializer);
    return ConnectionInfo(
      id: var_id,
      host: var_host,
      destination: var_destination,
      upload: var_upload,
      download: var_download,
      startTime: var_startTime,
      rule: var_rule,
      chains: var_chains,
    );
  }

  @protected
  DnsConfigDto sse_decode_dns_config_dto(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_enable = sse_decode_bool(deserializer);
    var var_listen = sse_decode_String(deserializer);
    var var_enhancedMode = sse_decode_String(deserializer);
    var var_nameservers = sse_decode_list_String(deserializer);
    var var_fallback = sse_decode_list_String(deserializer);
    return DnsConfigDto(
      enable: var_enable,
      listen: var_listen,
      enhancedMode: var_enhancedMode,
      nameservers: var_nameservers,
      fallback: var_fallback,
    );
  }

  @protected
  double sse_decode_f_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getFloat64();
  }

  @protected
  int sse_decode_i_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getInt32();
  }

  @protected
  PlatformInt64 sse_decode_i_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getPlatformInt64();
  }

  @protected
  LatencyTestResult sse_decode_latency_test_result(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_proxyName = sse_decode_String(deserializer);
    var var_latencyMs = sse_decode_opt_box_autoadd_u_32(deserializer);
    var var_success = sse_decode_bool(deserializer);
    var var_error = sse_decode_opt_String(deserializer);
    return LatencyTestResult(
      proxyName: var_proxyName,
      latencyMs: var_latencyMs,
      success: var_success,
      error: var_error,
    );
  }

  @protected
  List<String> sse_decode_list_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <String>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_String(deserializer));
    }
    return ans_;
  }

  @protected
  List<ActiveConnection> sse_decode_list_active_connection(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <ActiveConnection>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_active_connection(deserializer));
    }
    return ans_;
  }

  @protected
  List<ConnectionDto> sse_decode_list_connection_dto(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <ConnectionDto>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_connection_dto(deserializer));
    }
    return ans_;
  }

  @protected
  List<ConnectionInfo> sse_decode_list_connection_info(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <ConnectionInfo>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_connection_info(deserializer));
    }
    return ans_;
  }

  @protected
  List<LatencyTestResult> sse_decode_list_latency_test_result(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <LatencyTestResult>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_latency_test_result(deserializer));
    }
    return ans_;
  }

  @protected
  Uint8List sse_decode_list_prim_u_8_strict(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var len_ = sse_decode_i_32(deserializer);
    return deserializer.buffer.getUint8List(len_);
  }

  @protected
  List<ProxyGroupDto> sse_decode_list_proxy_group_dto(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <ProxyGroupDto>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_proxy_group_dto(deserializer));
    }
    return ans_;
  }

  @protected
  List<ProxyInfoDto> sse_decode_list_proxy_info_dto(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <ProxyInfoDto>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_proxy_info_dto(deserializer));
    }
    return ans_;
  }

  @protected
  List<ProxyLatencyDto> sse_decode_list_proxy_latency_dto(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <ProxyLatencyDto>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_proxy_latency_dto(deserializer));
    }
    return ans_;
  }

  @protected
  List<(String, int)> sse_decode_list_record_string_u_16(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <(String, int)>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_record_string_u_16(deserializer));
    }
    return ans_;
  }

  @protected
  List<RuleDto> sse_decode_list_rule_dto(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <RuleDto>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_rule_dto(deserializer));
    }
    return ans_;
  }

  @protected
  String? sse_decode_opt_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_String(deserializer));
    } else {
      return null;
    }
  }

  @protected
  int? sse_decode_opt_box_autoadd_u_16(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_u_16(deserializer));
    } else {
      return null;
    }
  }

  @protected
  int? sse_decode_opt_box_autoadd_u_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_u_32(deserializer));
    } else {
      return null;
    }
  }

  @protected
  BigInt? sse_decode_opt_box_autoadd_u_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_u_64(deserializer));
    } else {
      return null;
    }
  }

  @protected
  ProxyGroupDto sse_decode_proxy_group_dto(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_tag = sse_decode_String(deserializer);
    var var_groupType = sse_decode_String(deserializer);
    var var_proxies = sse_decode_list_String(deserializer);
    var var_selected = sse_decode_String(deserializer);
    return ProxyGroupDto(
      tag: var_tag,
      groupType: var_groupType,
      proxies: var_proxies,
      selected: var_selected,
    );
  }

  @protected
  ProxyInfoDto sse_decode_proxy_info_dto(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_tag = sse_decode_String(deserializer);
    var var_protocolType = sse_decode_String(deserializer);
    var var_server = sse_decode_opt_String(deserializer);
    var var_port = sse_decode_opt_box_autoadd_u_16(deserializer);
    var var_latencyMs = sse_decode_opt_box_autoadd_u_64(deserializer);
    var var_alive = sse_decode_bool(deserializer);
    return ProxyInfoDto(
      tag: var_tag,
      protocolType: var_protocolType,
      server: var_server,
      port: var_port,
      latencyMs: var_latencyMs,
      alive: var_alive,
    );
  }

  @protected
  ProxyLatencyDto sse_decode_proxy_latency_dto(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_tag = sse_decode_String(deserializer);
    var var_latencyMs = sse_decode_opt_box_autoadd_u_64(deserializer);
    var var_error = sse_decode_opt_String(deserializer);
    return ProxyLatencyDto(
      tag: var_tag,
      latencyMs: var_latencyMs,
      error: var_error,
    );
  }

  @protected
  ProxyStatus sse_decode_proxy_status(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_running = sse_decode_bool(deserializer);
    var var_inboundCount = sse_decode_u_32(deserializer);
    var var_outboundCount = sse_decode_u_32(deserializer);
    var var_connectionCount = sse_decode_u_32(deserializer);
    var var_memoryUsage = sse_decode_u_64(deserializer);
    var var_uptime = sse_decode_u_64(deserializer);
    return ProxyStatus(
      running: var_running,
      inboundCount: var_inboundCount,
      outboundCount: var_outboundCount,
      connectionCount: var_connectionCount,
      memoryUsage: var_memoryUsage,
      uptime: var_uptime,
    );
  }

  @protected
  (String, int) sse_decode_record_string_u_16(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_field0 = sse_decode_String(deserializer);
    var var_field1 = sse_decode_u_16(deserializer);
    return (var_field0, var_field1);
  }

  @protected
  (BigInt, BigInt, BigInt, BigInt) sse_decode_record_u_64_u_64_u_64_u_64(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_field0 = sse_decode_u_64(deserializer);
    var var_field1 = sse_decode_u_64(deserializer);
    var var_field2 = sse_decode_u_64(deserializer);
    var var_field3 = sse_decode_u_64(deserializer);
    return (var_field0, var_field1, var_field2, var_field3);
  }

  @protected
  (BigInt, BigInt, BigInt, BigInt, BigInt, BigInt)
  sse_decode_record_u_64_u_64_u_64_u_64_usize_usize(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_field0 = sse_decode_u_64(deserializer);
    var var_field1 = sse_decode_u_64(deserializer);
    var var_field2 = sse_decode_u_64(deserializer);
    var var_field3 = sse_decode_u_64(deserializer);
    var var_field4 = sse_decode_usize(deserializer);
    var var_field5 = sse_decode_usize(deserializer);
    return (
      var_field0,
      var_field1,
      var_field2,
      var_field3,
      var_field4,
      var_field5,
    );
  }

  @protected
  RuleDto sse_decode_rule_dto(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_ruleType = sse_decode_String(deserializer);
    var var_payload = sse_decode_String(deserializer);
    var var_outbound = sse_decode_String(deserializer);
    var var_matchedCount = sse_decode_u_64(deserializer);
    return RuleDto(
      ruleType: var_ruleType,
      payload: var_payload,
      outbound: var_outbound,
      matchedCount: var_matchedCount,
    );
  }

  @protected
  SystemInfo sse_decode_system_info(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_platform = sse_decode_String(deserializer);
    var var_version = sse_decode_String(deserializer);
    var var_memoryTotal = sse_decode_u_64(deserializer);
    var var_memoryUsed = sse_decode_u_64(deserializer);
    var var_cpuCores = sse_decode_u_32(deserializer);
    var var_cpuThreads = sse_decode_u_32(deserializer);
    var var_cpuName = sse_decode_String(deserializer);
    var var_cpuUsage = sse_decode_f_64(deserializer);
    return SystemInfo(
      platform: var_platform,
      version: var_version,
      memoryTotal: var_memoryTotal,
      memoryUsed: var_memoryUsed,
      cpuCores: var_cpuCores,
      cpuThreads: var_cpuThreads,
      cpuName: var_cpuName,
      cpuUsage: var_cpuUsage,
    );
  }

  @protected
  TrafficStats sse_decode_traffic_stats(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_upload = sse_decode_u_64(deserializer);
    var var_download = sse_decode_u_64(deserializer);
    var var_uploadSpeed = sse_decode_u_64(deserializer);
    var var_downloadSpeed = sse_decode_u_64(deserializer);
    return TrafficStats(
      upload: var_upload,
      download: var_download,
      uploadSpeed: var_uploadSpeed,
      downloadSpeed: var_downloadSpeed,
    );
  }

  @protected
  TrafficStatsDto sse_decode_traffic_stats_dto(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_upload = sse_decode_u_64(deserializer);
    var var_download = sse_decode_u_64(deserializer);
    var var_totalUpload = sse_decode_u_64(deserializer);
    var var_totalDownload = sse_decode_u_64(deserializer);
    var var_connectionCount = sse_decode_u_32(deserializer);
    var var_uptimeSecs = sse_decode_u_64(deserializer);
    return TrafficStatsDto(
      upload: var_upload,
      download: var_download,
      totalUpload: var_totalUpload,
      totalDownload: var_totalDownload,
      connectionCount: var_connectionCount,
      uptimeSecs: var_uptimeSecs,
    );
  }

  @protected
  TunStatus sse_decode_tun_status(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_enabled = sse_decode_bool(deserializer);
    var var_interfaceName = sse_decode_opt_String(deserializer);
    var var_mtu = sse_decode_opt_box_autoadd_u_32(deserializer);
    var var_error = sse_decode_opt_String(deserializer);
    return TunStatus(
      enabled: var_enabled,
      interfaceName: var_interfaceName,
      mtu: var_mtu,
      error: var_error,
    );
  }

  @protected
  int sse_decode_u_16(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint16();
  }

  @protected
  int sse_decode_u_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint32();
  }

  @protected
  BigInt sse_decode_u_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getBigUint64();
  }

  @protected
  int sse_decode_u_8(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint8();
  }

  @protected
  void sse_decode_unit(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
  }

  @protected
  BigInt sse_decode_usize(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getBigUint64();
  }

  @protected
  bool cst_encode_bool(bool raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return raw;
  }

  @protected
  double cst_encode_f_64(double raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return raw;
  }

  @protected
  int cst_encode_i_32(int raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return raw;
  }

  @protected
  int cst_encode_u_16(int raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return raw;
  }

  @protected
  int cst_encode_u_32(int raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return raw;
  }

  @protected
  int cst_encode_u_8(int raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return raw;
  }

  @protected
  void cst_encode_unit(void raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return raw;
  }

  @protected
  void sse_encode_AnyhowException(
    AnyhowException self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.message, serializer);
  }

  @protected
  void sse_encode_String(String self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(utf8.encoder.convert(self), serializer);
  }

  @protected
  void sse_encode_active_connection(
    ActiveConnection self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.id, serializer);
    sse_encode_String(self.inboundTag, serializer);
    sse_encode_String(self.outboundTag, serializer);
    sse_encode_String(self.host, serializer);
    sse_encode_opt_String(self.destinationIp, serializer);
    sse_encode_u_16(self.destinationPort, serializer);
    sse_encode_String(self.protocol, serializer);
    sse_encode_String(self.network, serializer);
    sse_encode_u_64(self.uploadBytes, serializer);
    sse_encode_u_64(self.downloadBytes, serializer);
    sse_encode_u_64(self.startTime, serializer);
    sse_encode_String(self.rule, serializer);
    sse_encode_String(self.rulePayload, serializer);
    sse_encode_opt_String(self.processName, serializer);
  }

  @protected
  void sse_encode_bool(bool self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint8(self ? 1 : 0);
  }

  @protected
  void sse_encode_box_autoadd_u_16(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_16(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_u_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_32(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_u_64(BigInt self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_64(self, serializer);
  }

  @protected
  void sse_encode_connection_dto(ConnectionDto self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.id, serializer);
    sse_encode_String(self.srcAddr, serializer);
    sse_encode_String(self.dstAddr, serializer);
    sse_encode_opt_String(self.dstDomain, serializer);
    sse_encode_String(self.protocol, serializer);
    sse_encode_String(self.outbound, serializer);
    sse_encode_u_64(self.upload, serializer);
    sse_encode_u_64(self.download, serializer);
    sse_encode_i_64(self.startTime, serializer);
    sse_encode_opt_String(self.rule, serializer);
  }

  @protected
  void sse_encode_connection_info(
    ConnectionInfo self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.id, serializer);
    sse_encode_String(self.host, serializer);
    sse_encode_String(self.destination, serializer);
    sse_encode_u_64(self.upload, serializer);
    sse_encode_u_64(self.download, serializer);
    sse_encode_u_64(self.startTime, serializer);
    sse_encode_String(self.rule, serializer);
    sse_encode_list_String(self.chains, serializer);
  }

  @protected
  void sse_encode_dns_config_dto(DnsConfigDto self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_bool(self.enable, serializer);
    sse_encode_String(self.listen, serializer);
    sse_encode_String(self.enhancedMode, serializer);
    sse_encode_list_String(self.nameservers, serializer);
    sse_encode_list_String(self.fallback, serializer);
  }

  @protected
  void sse_encode_f_64(double self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putFloat64(self);
  }

  @protected
  void sse_encode_i_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putInt32(self);
  }

  @protected
  void sse_encode_i_64(PlatformInt64 self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putPlatformInt64(self);
  }

  @protected
  void sse_encode_latency_test_result(
    LatencyTestResult self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.proxyName, serializer);
    sse_encode_opt_box_autoadd_u_32(self.latencyMs, serializer);
    sse_encode_bool(self.success, serializer);
    sse_encode_opt_String(self.error, serializer);
  }

  @protected
  void sse_encode_list_String(List<String> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_String(item, serializer);
    }
  }

  @protected
  void sse_encode_list_active_connection(
    List<ActiveConnection> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_active_connection(item, serializer);
    }
  }

  @protected
  void sse_encode_list_connection_dto(
    List<ConnectionDto> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_connection_dto(item, serializer);
    }
  }

  @protected
  void sse_encode_list_connection_info(
    List<ConnectionInfo> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_connection_info(item, serializer);
    }
  }

  @protected
  void sse_encode_list_latency_test_result(
    List<LatencyTestResult> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_latency_test_result(item, serializer);
    }
  }

  @protected
  void sse_encode_list_prim_u_8_strict(
    Uint8List self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    serializer.buffer.putUint8List(self);
  }

  @protected
  void sse_encode_list_proxy_group_dto(
    List<ProxyGroupDto> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_proxy_group_dto(item, serializer);
    }
  }

  @protected
  void sse_encode_list_proxy_info_dto(
    List<ProxyInfoDto> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_proxy_info_dto(item, serializer);
    }
  }

  @protected
  void sse_encode_list_proxy_latency_dto(
    List<ProxyLatencyDto> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_proxy_latency_dto(item, serializer);
    }
  }

  @protected
  void sse_encode_list_record_string_u_16(
    List<(String, int)> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_record_string_u_16(item, serializer);
    }
  }

  @protected
  void sse_encode_list_rule_dto(List<RuleDto> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_rule_dto(item, serializer);
    }
  }

  @protected
  void sse_encode_opt_String(String? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_String(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_u_16(int? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_u_16(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_u_32(int? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_u_32(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_u_64(BigInt? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_u_64(self, serializer);
    }
  }

  @protected
  void sse_encode_proxy_group_dto(
    ProxyGroupDto self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.tag, serializer);
    sse_encode_String(self.groupType, serializer);
    sse_encode_list_String(self.proxies, serializer);
    sse_encode_String(self.selected, serializer);
  }

  @protected
  void sse_encode_proxy_info_dto(ProxyInfoDto self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.tag, serializer);
    sse_encode_String(self.protocolType, serializer);
    sse_encode_opt_String(self.server, serializer);
    sse_encode_opt_box_autoadd_u_16(self.port, serializer);
    sse_encode_opt_box_autoadd_u_64(self.latencyMs, serializer);
    sse_encode_bool(self.alive, serializer);
  }

  @protected
  void sse_encode_proxy_latency_dto(
    ProxyLatencyDto self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.tag, serializer);
    sse_encode_opt_box_autoadd_u_64(self.latencyMs, serializer);
    sse_encode_opt_String(self.error, serializer);
  }

  @protected
  void sse_encode_proxy_status(ProxyStatus self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_bool(self.running, serializer);
    sse_encode_u_32(self.inboundCount, serializer);
    sse_encode_u_32(self.outboundCount, serializer);
    sse_encode_u_32(self.connectionCount, serializer);
    sse_encode_u_64(self.memoryUsage, serializer);
    sse_encode_u_64(self.uptime, serializer);
  }

  @protected
  void sse_encode_record_string_u_16(
    (String, int) self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.$1, serializer);
    sse_encode_u_16(self.$2, serializer);
  }

  @protected
  void sse_encode_record_u_64_u_64_u_64_u_64(
    (BigInt, BigInt, BigInt, BigInt) self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_64(self.$1, serializer);
    sse_encode_u_64(self.$2, serializer);
    sse_encode_u_64(self.$3, serializer);
    sse_encode_u_64(self.$4, serializer);
  }

  @protected
  void sse_encode_record_u_64_u_64_u_64_u_64_usize_usize(
    (BigInt, BigInt, BigInt, BigInt, BigInt, BigInt) self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_64(self.$1, serializer);
    sse_encode_u_64(self.$2, serializer);
    sse_encode_u_64(self.$3, serializer);
    sse_encode_u_64(self.$4, serializer);
    sse_encode_usize(self.$5, serializer);
    sse_encode_usize(self.$6, serializer);
  }

  @protected
  void sse_encode_rule_dto(RuleDto self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.ruleType, serializer);
    sse_encode_String(self.payload, serializer);
    sse_encode_String(self.outbound, serializer);
    sse_encode_u_64(self.matchedCount, serializer);
  }

  @protected
  void sse_encode_system_info(SystemInfo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.platform, serializer);
    sse_encode_String(self.version, serializer);
    sse_encode_u_64(self.memoryTotal, serializer);
    sse_encode_u_64(self.memoryUsed, serializer);
    sse_encode_u_32(self.cpuCores, serializer);
    sse_encode_u_32(self.cpuThreads, serializer);
    sse_encode_String(self.cpuName, serializer);
    sse_encode_f_64(self.cpuUsage, serializer);
  }

  @protected
  void sse_encode_traffic_stats(TrafficStats self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_64(self.upload, serializer);
    sse_encode_u_64(self.download, serializer);
    sse_encode_u_64(self.uploadSpeed, serializer);
    sse_encode_u_64(self.downloadSpeed, serializer);
  }

  @protected
  void sse_encode_traffic_stats_dto(
    TrafficStatsDto self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_64(self.upload, serializer);
    sse_encode_u_64(self.download, serializer);
    sse_encode_u_64(self.totalUpload, serializer);
    sse_encode_u_64(self.totalDownload, serializer);
    sse_encode_u_32(self.connectionCount, serializer);
    sse_encode_u_64(self.uptimeSecs, serializer);
  }

  @protected
  void sse_encode_tun_status(TunStatus self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_bool(self.enabled, serializer);
    sse_encode_opt_String(self.interfaceName, serializer);
    sse_encode_opt_box_autoadd_u_32(self.mtu, serializer);
    sse_encode_opt_String(self.error, serializer);
  }

  @protected
  void sse_encode_u_16(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint16(self);
  }

  @protected
  void sse_encode_u_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint32(self);
  }

  @protected
  void sse_encode_u_64(BigInt self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putBigUint64(self);
  }

  @protected
  void sse_encode_u_8(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint8(self);
  }

  @protected
  void sse_encode_unit(void self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
  }

  @protected
  void sse_encode_usize(BigInt self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putBigUint64(self);
  }
}
