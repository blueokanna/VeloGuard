// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: unused_import, unused_element, unnecessary_import, duplicate_ignore, invalid_use_of_internal_member, annotate_overrides, non_constant_identifier_names, curly_braces_in_flow_control_structures, prefer_const_literals_to_create_immutables, unused_field

import 'api.dart';
import 'dart:async';
import 'dart:convert';
import 'frb_generated.dart';
import 'frb_generated.io.dart'
    if (dart.library.js_interop) 'frb_generated.web.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'types.dart';

/// Main entrypoint of the Rust API
class RustLib extends BaseEntrypoint<RustLibApi, RustLibApiImpl, RustLibWire> {
  @internal
  static final instance = RustLib._();

  RustLib._();

  /// Initialize flutter_rust_bridge
  static Future<void> init({
    RustLibApi? api,
    BaseHandler? handler,
    ExternalLibrary? externalLibrary,
    bool forceSameCodegenVersion = true,
  }) async {
    await instance.initImpl(
      api: api,
      handler: handler,
      externalLibrary: externalLibrary,
      forceSameCodegenVersion: forceSameCodegenVersion,
    );
  }

  /// Initialize flutter_rust_bridge in mock mode.
  /// No libraries for FFI are loaded.
  static void initMock({required RustLibApi api}) {
    instance.initMockImpl(api: api);
  }

  /// Dispose flutter_rust_bridge
  ///
  /// The call to this function is optional, since flutter_rust_bridge (and everything else)
  /// is automatically disposed when the app stops.
  static void dispose() => instance.disposeImpl();

  @override
  ApiImplConstructor<RustLibApiImpl, RustLibWire> get apiImplConstructor =>
      RustLibApiImpl.new;

  @override
  WireConstructor<RustLibWire> get wireConstructor =>
      RustLibWire.fromExternalLibrary;

  @override
  Future<void> executeRustInitializers() async {}

  @override
  ExternalLibraryLoaderConfig get defaultExternalLibraryLoaderConfig =>
      kDefaultExternalLibraryLoaderConfig;

  @override
  String get codegenVersion => '2.11.1';

  @override
  int get rustContentHash => -543989103;

  static const kDefaultExternalLibraryLoaderConfig =
      ExternalLibraryLoaderConfig(
        stem: 'rust_lib_veloguard',
        ioDirectory: 'rust/veloguard-lib/target/release/',
        webPrefix: 'pkg/',
      );
}

abstract class RustLibApi extends BaseApi {
  Future<void> crateApiClearAndroidVpnFd();

  Future<bool> crateApiCloseActiveConnection({required String connectionId});

  Future<void> crateApiCloseAllConnections();

  Future<void> crateApiCloseConnection({required String connectionId});

  Future<TunStatus> crateApiDisableTunMode();

  Future<TunStatus> crateApiEnableTunMode();

  Future<bool> crateApiEnableUwpLoopback();

  Future<String> crateApiEnsureWintunDll();

  Future<List<ActiveConnection>> crateApiGetActiveConnections();

  Future<String> crateApiGetAndroidProxyMode();

  Future<int> crateApiGetAndroidVpnFd();

  Future<String> crateApiGetBuildInfo();

  Future<(BigInt, BigInt, BigInt, BigInt)> crateApiGetConnectionStats();

  Future<List<ConnectionInfo>> crateApiGetConnections();

  Future<List<String>> crateApiGetLogs({int? lines});

  Future<String?> crateApiGetSelectedProxyInGroup({required String groupName});

  Future<SystemInfo> crateApiGetSystemInfo();

  Future<TrafficStats> crateApiGetTrafficStats();

  Future<TunStatus> crateApiGetTunStatus();

  Future<ProxyStatus> crateApiGetVeloguardStatus();

  Future<String> crateApiGetVersion();

  Future<String?> crateApiGetWintunDllPath();

  Future<void> crateApiInitializeVeloguard({required String configJson});

  Future<bool> crateApiIsWintunAvailable();

  Future<bool> crateApiOpenUwpLoopbackUtility();

  Future<void> crateApiReloadVeloguard({required String configJson});

  Future<bool> crateApiSelectProxyInGroup({
    required String groupName,
    required String proxyName,
  });

  Future<void> crateApiSetAndroidProxyMode({required String mode});

  Future<void> crateApiSetAndroidVpnFd({required int fd});

  Future<void> crateApiSetLogLevel({required String level});

  Future<bool> crateApiStartAndroidVpn();

  Future<void> crateApiStartVeloguard();

  Future<bool> crateApiStopAndroidVpn();

  Future<void> crateApiStopVeloguard();

  Future<bool> crateApiTestConfig({required String configJson});

  Future<LatencyTestResult> crateApiTestOutboundLatency({
    required String outboundName,
    required int timeoutMs,
  });

  Future<List<LatencyTestResult>> crateApiTestProxiesLatency({
    required List<(String, int)> proxies,
    required int timeoutMs,
  });

  Future<LatencyTestResult> crateApiTestProxyLatency({
    required String server,
    required int port,
    required int timeoutMs,
  });

  Future<LatencyTestResult> crateApiTestShadowsocksLatency({
    required String server,
    required int port,
    required String password,
    required String cipher,
    required int timeoutMs,
  });

  Future<LatencyTestResult> crateApiTestTcpConnectivity({
    required String server,
    required int port,
    required int timeoutMs,
  });
}

class RustLibApiImpl extends RustLibApiImplPlatform implements RustLibApi {
  RustLibApiImpl({
    required super.handler,
    required super.wire,
    required super.generalizedFrbRustBinding,
    required super.portManager,
  });

  @override
  Future<void> crateApiClearAndroidVpnFd() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 1,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiClearAndroidVpnFdConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiClearAndroidVpnFdConstMeta =>
      const TaskConstMeta(debugName: "clear_android_vpn_fd", argNames: []);

  @override
  Future<bool> crateApiCloseActiveConnection({required String connectionId}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(connectionId, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 2,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_bool,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiCloseActiveConnectionConstMeta,
        argValues: [connectionId],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiCloseActiveConnectionConstMeta =>
      const TaskConstMeta(
        debugName: "close_active_connection",
        argNames: ["connectionId"],
      );

  @override
  Future<void> crateApiCloseAllConnections() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 3,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiCloseAllConnectionsConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiCloseAllConnectionsConstMeta =>
      const TaskConstMeta(debugName: "close_all_connections", argNames: []);

  @override
  Future<void> crateApiCloseConnection({required String connectionId}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(connectionId, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 4,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiCloseConnectionConstMeta,
        argValues: [connectionId],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiCloseConnectionConstMeta => const TaskConstMeta(
    debugName: "close_connection",
    argNames: ["connectionId"],
  );

  @override
  Future<TunStatus> crateApiDisableTunMode() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 5,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_tun_status,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiDisableTunModeConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiDisableTunModeConstMeta =>
      const TaskConstMeta(debugName: "disable_tun_mode", argNames: []);

  @override
  Future<TunStatus> crateApiEnableTunMode() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 6,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_tun_status,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiEnableTunModeConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiEnableTunModeConstMeta =>
      const TaskConstMeta(debugName: "enable_tun_mode", argNames: []);

  @override
  Future<bool> crateApiEnableUwpLoopback() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 7,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_bool,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiEnableUwpLoopbackConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiEnableUwpLoopbackConstMeta =>
      const TaskConstMeta(debugName: "enable_uwp_loopback", argNames: []);

  @override
  Future<String> crateApiEnsureWintunDll() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 8,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiEnsureWintunDllConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiEnsureWintunDllConstMeta =>
      const TaskConstMeta(debugName: "ensure_wintun_dll", argNames: []);

  @override
  Future<List<ActiveConnection>> crateApiGetActiveConnections() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 9,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_list_active_connection,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiGetActiveConnectionsConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiGetActiveConnectionsConstMeta =>
      const TaskConstMeta(debugName: "get_active_connections", argNames: []);

  @override
  Future<String> crateApiGetAndroidProxyMode() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 10,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiGetAndroidProxyModeConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiGetAndroidProxyModeConstMeta =>
      const TaskConstMeta(debugName: "get_android_proxy_mode", argNames: []);

  @override
  Future<int> crateApiGetAndroidVpnFd() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 11,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_i_32,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiGetAndroidVpnFdConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiGetAndroidVpnFdConstMeta =>
      const TaskConstMeta(debugName: "get_android_vpn_fd", argNames: []);

  @override
  Future<String> crateApiGetBuildInfo() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 12,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiGetBuildInfoConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiGetBuildInfoConstMeta =>
      const TaskConstMeta(debugName: "get_build_info", argNames: []);

  @override
  Future<(BigInt, BigInt, BigInt, BigInt)> crateApiGetConnectionStats() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 13,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_record_u_64_u_64_u_64_u_64,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiGetConnectionStatsConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiGetConnectionStatsConstMeta =>
      const TaskConstMeta(debugName: "get_connection_stats", argNames: []);

  @override
  Future<List<ConnectionInfo>> crateApiGetConnections() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 14,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_list_connection_info,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiGetConnectionsConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiGetConnectionsConstMeta =>
      const TaskConstMeta(debugName: "get_connections", argNames: []);

  @override
  Future<List<String>> crateApiGetLogs({int? lines}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_opt_box_autoadd_u_32(lines, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 15,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_list_String,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiGetLogsConstMeta,
        argValues: [lines],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiGetLogsConstMeta =>
      const TaskConstMeta(debugName: "get_logs", argNames: ["lines"]);

  @override
  Future<String?> crateApiGetSelectedProxyInGroup({required String groupName}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(groupName, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 16,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_opt_String,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiGetSelectedProxyInGroupConstMeta,
        argValues: [groupName],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiGetSelectedProxyInGroupConstMeta =>
      const TaskConstMeta(
        debugName: "get_selected_proxy_in_group",
        argNames: ["groupName"],
      );

  @override
  Future<SystemInfo> crateApiGetSystemInfo() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 17,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_system_info,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiGetSystemInfoConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiGetSystemInfoConstMeta =>
      const TaskConstMeta(debugName: "get_system_info", argNames: []);

  @override
  Future<TrafficStats> crateApiGetTrafficStats() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 18,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_traffic_stats,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiGetTrafficStatsConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiGetTrafficStatsConstMeta =>
      const TaskConstMeta(debugName: "get_traffic_stats", argNames: []);

  @override
  Future<TunStatus> crateApiGetTunStatus() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 19,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_tun_status,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiGetTunStatusConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiGetTunStatusConstMeta =>
      const TaskConstMeta(debugName: "get_tun_status", argNames: []);

  @override
  Future<ProxyStatus> crateApiGetVeloguardStatus() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 20,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_proxy_status,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiGetVeloguardStatusConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiGetVeloguardStatusConstMeta =>
      const TaskConstMeta(debugName: "get_veloguard_status", argNames: []);

  @override
  Future<String> crateApiGetVersion() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 21,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiGetVersionConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiGetVersionConstMeta =>
      const TaskConstMeta(debugName: "get_version", argNames: []);

  @override
  Future<String?> crateApiGetWintunDllPath() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 22,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_opt_String,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiGetWintunDllPathConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiGetWintunDllPathConstMeta =>
      const TaskConstMeta(debugName: "get_wintun_dll_path", argNames: []);

  @override
  Future<void> crateApiInitializeVeloguard({required String configJson}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(configJson, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 23,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiInitializeVeloguardConstMeta,
        argValues: [configJson],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiInitializeVeloguardConstMeta =>
      const TaskConstMeta(
        debugName: "initialize_veloguard",
        argNames: ["configJson"],
      );

  @override
  Future<bool> crateApiIsWintunAvailable() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 24,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_bool,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiIsWintunAvailableConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiIsWintunAvailableConstMeta =>
      const TaskConstMeta(debugName: "is_wintun_available", argNames: []);

  @override
  Future<bool> crateApiOpenUwpLoopbackUtility() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 25,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_bool,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiOpenUwpLoopbackUtilityConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiOpenUwpLoopbackUtilityConstMeta =>
      const TaskConstMeta(debugName: "open_uwp_loopback_utility", argNames: []);

  @override
  Future<void> crateApiReloadVeloguard({required String configJson}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(configJson, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 26,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiReloadVeloguardConstMeta,
        argValues: [configJson],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiReloadVeloguardConstMeta => const TaskConstMeta(
    debugName: "reload_veloguard",
    argNames: ["configJson"],
  );

  @override
  Future<bool> crateApiSelectProxyInGroup({
    required String groupName,
    required String proxyName,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(groupName, serializer);
          sse_encode_String(proxyName, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 27,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_bool,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiSelectProxyInGroupConstMeta,
        argValues: [groupName, proxyName],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiSelectProxyInGroupConstMeta => const TaskConstMeta(
    debugName: "select_proxy_in_group",
    argNames: ["groupName", "proxyName"],
  );

  @override
  Future<void> crateApiSetAndroidProxyMode({required String mode}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(mode, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 28,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiSetAndroidProxyModeConstMeta,
        argValues: [mode],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiSetAndroidProxyModeConstMeta =>
      const TaskConstMeta(
        debugName: "set_android_proxy_mode",
        argNames: ["mode"],
      );

  @override
  Future<void> crateApiSetAndroidVpnFd({required int fd}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_i_32(fd, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 29,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiSetAndroidVpnFdConstMeta,
        argValues: [fd],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiSetAndroidVpnFdConstMeta =>
      const TaskConstMeta(debugName: "set_android_vpn_fd", argNames: ["fd"]);

  @override
  Future<void> crateApiSetLogLevel({required String level}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(level, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 30,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiSetLogLevelConstMeta,
        argValues: [level],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiSetLogLevelConstMeta =>
      const TaskConstMeta(debugName: "set_log_level", argNames: ["level"]);

  @override
  Future<bool> crateApiStartAndroidVpn() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 31,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_bool,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiStartAndroidVpnConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiStartAndroidVpnConstMeta =>
      const TaskConstMeta(debugName: "start_android_vpn", argNames: []);

  @override
  Future<void> crateApiStartVeloguard() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 32,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiStartVeloguardConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiStartVeloguardConstMeta =>
      const TaskConstMeta(debugName: "start_veloguard", argNames: []);

  @override
  Future<bool> crateApiStopAndroidVpn() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 33,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_bool,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiStopAndroidVpnConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiStopAndroidVpnConstMeta =>
      const TaskConstMeta(debugName: "stop_android_vpn", argNames: []);

  @override
  Future<void> crateApiStopVeloguard() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 34,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiStopVeloguardConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiStopVeloguardConstMeta =>
      const TaskConstMeta(debugName: "stop_veloguard", argNames: []);

  @override
  Future<bool> crateApiTestConfig({required String configJson}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(configJson, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 35,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_bool,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiTestConfigConstMeta,
        argValues: [configJson],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiTestConfigConstMeta =>
      const TaskConstMeta(debugName: "test_config", argNames: ["configJson"]);

  @override
  Future<LatencyTestResult> crateApiTestOutboundLatency({
    required String outboundName,
    required int timeoutMs,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(outboundName, serializer);
          sse_encode_u_32(timeoutMs, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 36,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_latency_test_result,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiTestOutboundLatencyConstMeta,
        argValues: [outboundName, timeoutMs],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiTestOutboundLatencyConstMeta =>
      const TaskConstMeta(
        debugName: "test_outbound_latency",
        argNames: ["outboundName", "timeoutMs"],
      );

  @override
  Future<List<LatencyTestResult>> crateApiTestProxiesLatency({
    required List<(String, int)> proxies,
    required int timeoutMs,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_list_record_string_u_16(proxies, serializer);
          sse_encode_u_32(timeoutMs, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 37,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_list_latency_test_result,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiTestProxiesLatencyConstMeta,
        argValues: [proxies, timeoutMs],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiTestProxiesLatencyConstMeta => const TaskConstMeta(
    debugName: "test_proxies_latency",
    argNames: ["proxies", "timeoutMs"],
  );

  @override
  Future<LatencyTestResult> crateApiTestProxyLatency({
    required String server,
    required int port,
    required int timeoutMs,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(server, serializer);
          sse_encode_u_16(port, serializer);
          sse_encode_u_32(timeoutMs, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 38,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_latency_test_result,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiTestProxyLatencyConstMeta,
        argValues: [server, port, timeoutMs],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiTestProxyLatencyConstMeta => const TaskConstMeta(
    debugName: "test_proxy_latency",
    argNames: ["server", "port", "timeoutMs"],
  );

  @override
  Future<LatencyTestResult> crateApiTestShadowsocksLatency({
    required String server,
    required int port,
    required String password,
    required String cipher,
    required int timeoutMs,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(server, serializer);
          sse_encode_u_16(port, serializer);
          sse_encode_String(password, serializer);
          sse_encode_String(cipher, serializer);
          sse_encode_u_32(timeoutMs, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 39,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_latency_test_result,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiTestShadowsocksLatencyConstMeta,
        argValues: [server, port, password, cipher, timeoutMs],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiTestShadowsocksLatencyConstMeta =>
      const TaskConstMeta(
        debugName: "test_shadowsocks_latency",
        argNames: ["server", "port", "password", "cipher", "timeoutMs"],
      );

  @override
  Future<LatencyTestResult> crateApiTestTcpConnectivity({
    required String server,
    required int port,
    required int timeoutMs,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(server, serializer);
          sse_encode_u_16(port, serializer);
          sse_encode_u_32(timeoutMs, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 40,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_latency_test_result,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiTestTcpConnectivityConstMeta,
        argValues: [server, port, timeoutMs],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiTestTcpConnectivityConstMeta =>
      const TaskConstMeta(
        debugName: "test_tcp_connectivity",
        argNames: ["server", "port", "timeoutMs"],
      );

  @protected
  AnyhowException dco_decode_AnyhowException(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return AnyhowException(raw as String);
  }

  @protected
  String dco_decode_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as String;
  }

  @protected
  ActiveConnection dco_decode_active_connection(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 14)
      throw Exception('unexpected arr length: expect 14 but see ${arr.length}');
    return ActiveConnection(
      id: dco_decode_String(arr[0]),
      inboundTag: dco_decode_String(arr[1]),
      outboundTag: dco_decode_String(arr[2]),
      host: dco_decode_String(arr[3]),
      destinationIp: dco_decode_opt_String(arr[4]),
      destinationPort: dco_decode_u_16(arr[5]),
      protocol: dco_decode_String(arr[6]),
      network: dco_decode_String(arr[7]),
      uploadBytes: dco_decode_u_64(arr[8]),
      downloadBytes: dco_decode_u_64(arr[9]),
      startTime: dco_decode_u_64(arr[10]),
      rule: dco_decode_String(arr[11]),
      rulePayload: dco_decode_String(arr[12]),
      processName: dco_decode_opt_String(arr[13]),
    );
  }

  @protected
  bool dco_decode_bool(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as bool;
  }

  @protected
  int dco_decode_box_autoadd_u_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  ConnectionInfo dco_decode_connection_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 8)
      throw Exception('unexpected arr length: expect 8 but see ${arr.length}');
    return ConnectionInfo(
      id: dco_decode_String(arr[0]),
      host: dco_decode_String(arr[1]),
      destination: dco_decode_String(arr[2]),
      upload: dco_decode_u_64(arr[3]),
      download: dco_decode_u_64(arr[4]),
      startTime: dco_decode_u_64(arr[5]),
      rule: dco_decode_String(arr[6]),
      chains: dco_decode_list_String(arr[7]),
    );
  }

  @protected
  double dco_decode_f_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as double;
  }

  @protected
  int dco_decode_i_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  LatencyTestResult dco_decode_latency_test_result(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4)
      throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return LatencyTestResult(
      proxyName: dco_decode_String(arr[0]),
      latencyMs: dco_decode_opt_box_autoadd_u_32(arr[1]),
      success: dco_decode_bool(arr[2]),
      error: dco_decode_opt_String(arr[3]),
    );
  }

  @protected
  List<String> dco_decode_list_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_String).toList();
  }

  @protected
  List<ActiveConnection> dco_decode_list_active_connection(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_active_connection).toList();
  }

  @protected
  List<ConnectionInfo> dco_decode_list_connection_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_connection_info).toList();
  }

  @protected
  List<LatencyTestResult> dco_decode_list_latency_test_result(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_latency_test_result).toList();
  }

  @protected
  Uint8List dco_decode_list_prim_u_8_strict(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as Uint8List;
  }

  @protected
  List<(String, int)> dco_decode_list_record_string_u_16(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_record_string_u_16).toList();
  }

  @protected
  String? dco_decode_opt_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_String(raw);
  }

  @protected
  int? dco_decode_opt_box_autoadd_u_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_u_32(raw);
  }

  @protected
  ProxyStatus dco_decode_proxy_status(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 6)
      throw Exception('unexpected arr length: expect 6 but see ${arr.length}');
    return ProxyStatus(
      running: dco_decode_bool(arr[0]),
      inboundCount: dco_decode_u_32(arr[1]),
      outboundCount: dco_decode_u_32(arr[2]),
      connectionCount: dco_decode_u_32(arr[3]),
      memoryUsage: dco_decode_u_64(arr[4]),
      uptime: dco_decode_u_64(arr[5]),
    );
  }

  @protected
  (String, int) dco_decode_record_string_u_16(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2) {
      throw Exception('Expected 2 elements, got ${arr.length}');
    }
    return (dco_decode_String(arr[0]), dco_decode_u_16(arr[1]));
  }

  @protected
  (BigInt, BigInt, BigInt, BigInt) dco_decode_record_u_64_u_64_u_64_u_64(
    dynamic raw,
  ) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4) {
      throw Exception('Expected 4 elements, got ${arr.length}');
    }
    return (
      dco_decode_u_64(arr[0]),
      dco_decode_u_64(arr[1]),
      dco_decode_u_64(arr[2]),
      dco_decode_u_64(arr[3]),
    );
  }

  @protected
  SystemInfo dco_decode_system_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 8)
      throw Exception('unexpected arr length: expect 8 but see ${arr.length}');
    return SystemInfo(
      platform: dco_decode_String(arr[0]),
      version: dco_decode_String(arr[1]),
      memoryTotal: dco_decode_u_64(arr[2]),
      memoryUsed: dco_decode_u_64(arr[3]),
      cpuCores: dco_decode_u_32(arr[4]),
      cpuThreads: dco_decode_u_32(arr[5]),
      cpuName: dco_decode_String(arr[6]),
      cpuUsage: dco_decode_f_64(arr[7]),
    );
  }

  @protected
  TrafficStats dco_decode_traffic_stats(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4)
      throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return TrafficStats(
      upload: dco_decode_u_64(arr[0]),
      download: dco_decode_u_64(arr[1]),
      uploadSpeed: dco_decode_u_64(arr[2]),
      downloadSpeed: dco_decode_u_64(arr[3]),
    );
  }

  @protected
  TunStatus dco_decode_tun_status(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4)
      throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return TunStatus(
      enabled: dco_decode_bool(arr[0]),
      interfaceName: dco_decode_opt_String(arr[1]),
      mtu: dco_decode_opt_box_autoadd_u_32(arr[2]),
      error: dco_decode_opt_String(arr[3]),
    );
  }

  @protected
  int dco_decode_u_16(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  int dco_decode_u_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  BigInt dco_decode_u_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dcoDecodeU64(raw);
  }

  @protected
  int dco_decode_u_8(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  void dco_decode_unit(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return;
  }

  @protected
  AnyhowException sse_decode_AnyhowException(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_String(deserializer);
    return AnyhowException(inner);
  }

  @protected
  String sse_decode_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_list_prim_u_8_strict(deserializer);
    return utf8.decoder.convert(inner);
  }

  @protected
  ActiveConnection sse_decode_active_connection(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_id = sse_decode_String(deserializer);
    var var_inboundTag = sse_decode_String(deserializer);
    var var_outboundTag = sse_decode_String(deserializer);
    var var_host = sse_decode_String(deserializer);
    var var_destinationIp = sse_decode_opt_String(deserializer);
    var var_destinationPort = sse_decode_u_16(deserializer);
    var var_protocol = sse_decode_String(deserializer);
    var var_network = sse_decode_String(deserializer);
    var var_uploadBytes = sse_decode_u_64(deserializer);
    var var_downloadBytes = sse_decode_u_64(deserializer);
    var var_startTime = sse_decode_u_64(deserializer);
    var var_rule = sse_decode_String(deserializer);
    var var_rulePayload = sse_decode_String(deserializer);
    var var_processName = sse_decode_opt_String(deserializer);
    return ActiveConnection(
      id: var_id,
      inboundTag: var_inboundTag,
      outboundTag: var_outboundTag,
      host: var_host,
      destinationIp: var_destinationIp,
      destinationPort: var_destinationPort,
      protocol: var_protocol,
      network: var_network,
      uploadBytes: var_uploadBytes,
      downloadBytes: var_downloadBytes,
      startTime: var_startTime,
      rule: var_rule,
      rulePayload: var_rulePayload,
      processName: var_processName,
    );
  }

  @protected
  bool sse_decode_bool(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint8() != 0;
  }

  @protected
  int sse_decode_box_autoadd_u_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_u_32(deserializer));
  }

  @protected
  ConnectionInfo sse_decode_connection_info(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_id = sse_decode_String(deserializer);
    var var_host = sse_decode_String(deserializer);
    var var_destination = sse_decode_String(deserializer);
    var var_upload = sse_decode_u_64(deserializer);
    var var_download = sse_decode_u_64(deserializer);
    var var_startTime = sse_decode_u_64(deserializer);
    var var_rule = sse_decode_String(deserializer);
    var var_chains = sse_decode_list_String(deserializer);
    return ConnectionInfo(
      id: var_id,
      host: var_host,
      destination: var_destination,
      upload: var_upload,
      download: var_download,
      startTime: var_startTime,
      rule: var_rule,
      chains: var_chains,
    );
  }

  @protected
  double sse_decode_f_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getFloat64();
  }

  @protected
  int sse_decode_i_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getInt32();
  }

  @protected
  LatencyTestResult sse_decode_latency_test_result(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_proxyName = sse_decode_String(deserializer);
    var var_latencyMs = sse_decode_opt_box_autoadd_u_32(deserializer);
    var var_success = sse_decode_bool(deserializer);
    var var_error = sse_decode_opt_String(deserializer);
    return LatencyTestResult(
      proxyName: var_proxyName,
      latencyMs: var_latencyMs,
      success: var_success,
      error: var_error,
    );
  }

  @protected
  List<String> sse_decode_list_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <String>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_String(deserializer));
    }
    return ans_;
  }

  @protected
  List<ActiveConnection> sse_decode_list_active_connection(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <ActiveConnection>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_active_connection(deserializer));
    }
    return ans_;
  }

  @protected
  List<ConnectionInfo> sse_decode_list_connection_info(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <ConnectionInfo>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_connection_info(deserializer));
    }
    return ans_;
  }

  @protected
  List<LatencyTestResult> sse_decode_list_latency_test_result(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <LatencyTestResult>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_latency_test_result(deserializer));
    }
    return ans_;
  }

  @protected
  Uint8List sse_decode_list_prim_u_8_strict(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var len_ = sse_decode_i_32(deserializer);
    return deserializer.buffer.getUint8List(len_);
  }

  @protected
  List<(String, int)> sse_decode_list_record_string_u_16(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <(String, int)>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_record_string_u_16(deserializer));
    }
    return ans_;
  }

  @protected
  String? sse_decode_opt_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_String(deserializer));
    } else {
      return null;
    }
  }

  @protected
  int? sse_decode_opt_box_autoadd_u_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_u_32(deserializer));
    } else {
      return null;
    }
  }

  @protected
  ProxyStatus sse_decode_proxy_status(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_running = sse_decode_bool(deserializer);
    var var_inboundCount = sse_decode_u_32(deserializer);
    var var_outboundCount = sse_decode_u_32(deserializer);
    var var_connectionCount = sse_decode_u_32(deserializer);
    var var_memoryUsage = sse_decode_u_64(deserializer);
    var var_uptime = sse_decode_u_64(deserializer);
    return ProxyStatus(
      running: var_running,
      inboundCount: var_inboundCount,
      outboundCount: var_outboundCount,
      connectionCount: var_connectionCount,
      memoryUsage: var_memoryUsage,
      uptime: var_uptime,
    );
  }

  @protected
  (String, int) sse_decode_record_string_u_16(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_field0 = sse_decode_String(deserializer);
    var var_field1 = sse_decode_u_16(deserializer);
    return (var_field0, var_field1);
  }

  @protected
  (BigInt, BigInt, BigInt, BigInt) sse_decode_record_u_64_u_64_u_64_u_64(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_field0 = sse_decode_u_64(deserializer);
    var var_field1 = sse_decode_u_64(deserializer);
    var var_field2 = sse_decode_u_64(deserializer);
    var var_field3 = sse_decode_u_64(deserializer);
    return (var_field0, var_field1, var_field2, var_field3);
  }

  @protected
  SystemInfo sse_decode_system_info(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_platform = sse_decode_String(deserializer);
    var var_version = sse_decode_String(deserializer);
    var var_memoryTotal = sse_decode_u_64(deserializer);
    var var_memoryUsed = sse_decode_u_64(deserializer);
    var var_cpuCores = sse_decode_u_32(deserializer);
    var var_cpuThreads = sse_decode_u_32(deserializer);
    var var_cpuName = sse_decode_String(deserializer);
    var var_cpuUsage = sse_decode_f_64(deserializer);
    return SystemInfo(
      platform: var_platform,
      version: var_version,
      memoryTotal: var_memoryTotal,
      memoryUsed: var_memoryUsed,
      cpuCores: var_cpuCores,
      cpuThreads: var_cpuThreads,
      cpuName: var_cpuName,
      cpuUsage: var_cpuUsage,
    );
  }

  @protected
  TrafficStats sse_decode_traffic_stats(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_upload = sse_decode_u_64(deserializer);
    var var_download = sse_decode_u_64(deserializer);
    var var_uploadSpeed = sse_decode_u_64(deserializer);
    var var_downloadSpeed = sse_decode_u_64(deserializer);
    return TrafficStats(
      upload: var_upload,
      download: var_download,
      uploadSpeed: var_uploadSpeed,
      downloadSpeed: var_downloadSpeed,
    );
  }

  @protected
  TunStatus sse_decode_tun_status(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_enabled = sse_decode_bool(deserializer);
    var var_interfaceName = sse_decode_opt_String(deserializer);
    var var_mtu = sse_decode_opt_box_autoadd_u_32(deserializer);
    var var_error = sse_decode_opt_String(deserializer);
    return TunStatus(
      enabled: var_enabled,
      interfaceName: var_interfaceName,
      mtu: var_mtu,
      error: var_error,
    );
  }

  @protected
  int sse_decode_u_16(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint16();
  }

  @protected
  int sse_decode_u_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint32();
  }

  @protected
  BigInt sse_decode_u_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getBigUint64();
  }

  @protected
  int sse_decode_u_8(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint8();
  }

  @protected
  void sse_decode_unit(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
  }

  @protected
  void sse_encode_AnyhowException(
    AnyhowException self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.message, serializer);
  }

  @protected
  void sse_encode_String(String self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(utf8.encoder.convert(self), serializer);
  }

  @protected
  void sse_encode_active_connection(
    ActiveConnection self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.id, serializer);
    sse_encode_String(self.inboundTag, serializer);
    sse_encode_String(self.outboundTag, serializer);
    sse_encode_String(self.host, serializer);
    sse_encode_opt_String(self.destinationIp, serializer);
    sse_encode_u_16(self.destinationPort, serializer);
    sse_encode_String(self.protocol, serializer);
    sse_encode_String(self.network, serializer);
    sse_encode_u_64(self.uploadBytes, serializer);
    sse_encode_u_64(self.downloadBytes, serializer);
    sse_encode_u_64(self.startTime, serializer);
    sse_encode_String(self.rule, serializer);
    sse_encode_String(self.rulePayload, serializer);
    sse_encode_opt_String(self.processName, serializer);
  }

  @protected
  void sse_encode_bool(bool self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint8(self ? 1 : 0);
  }

  @protected
  void sse_encode_box_autoadd_u_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_32(self, serializer);
  }

  @protected
  void sse_encode_connection_info(
    ConnectionInfo self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.id, serializer);
    sse_encode_String(self.host, serializer);
    sse_encode_String(self.destination, serializer);
    sse_encode_u_64(self.upload, serializer);
    sse_encode_u_64(self.download, serializer);
    sse_encode_u_64(self.startTime, serializer);
    sse_encode_String(self.rule, serializer);
    sse_encode_list_String(self.chains, serializer);
  }

  @protected
  void sse_encode_f_64(double self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putFloat64(self);
  }

  @protected
  void sse_encode_i_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putInt32(self);
  }

  @protected
  void sse_encode_latency_test_result(
    LatencyTestResult self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.proxyName, serializer);
    sse_encode_opt_box_autoadd_u_32(self.latencyMs, serializer);
    sse_encode_bool(self.success, serializer);
    sse_encode_opt_String(self.error, serializer);
  }

  @protected
  void sse_encode_list_String(List<String> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_String(item, serializer);
    }
  }

  @protected
  void sse_encode_list_active_connection(
    List<ActiveConnection> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_active_connection(item, serializer);
    }
  }

  @protected
  void sse_encode_list_connection_info(
    List<ConnectionInfo> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_connection_info(item, serializer);
    }
  }

  @protected
  void sse_encode_list_latency_test_result(
    List<LatencyTestResult> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_latency_test_result(item, serializer);
    }
  }

  @protected
  void sse_encode_list_prim_u_8_strict(
    Uint8List self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    serializer.buffer.putUint8List(self);
  }

  @protected
  void sse_encode_list_record_string_u_16(
    List<(String, int)> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_record_string_u_16(item, serializer);
    }
  }

  @protected
  void sse_encode_opt_String(String? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_String(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_u_32(int? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_u_32(self, serializer);
    }
  }

  @protected
  void sse_encode_proxy_status(ProxyStatus self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_bool(self.running, serializer);
    sse_encode_u_32(self.inboundCount, serializer);
    sse_encode_u_32(self.outboundCount, serializer);
    sse_encode_u_32(self.connectionCount, serializer);
    sse_encode_u_64(self.memoryUsage, serializer);
    sse_encode_u_64(self.uptime, serializer);
  }

  @protected
  void sse_encode_record_string_u_16(
    (String, int) self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.$1, serializer);
    sse_encode_u_16(self.$2, serializer);
  }

  @protected
  void sse_encode_record_u_64_u_64_u_64_u_64(
    (BigInt, BigInt, BigInt, BigInt) self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_64(self.$1, serializer);
    sse_encode_u_64(self.$2, serializer);
    sse_encode_u_64(self.$3, serializer);
    sse_encode_u_64(self.$4, serializer);
  }

  @protected
  void sse_encode_system_info(SystemInfo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.platform, serializer);
    sse_encode_String(self.version, serializer);
    sse_encode_u_64(self.memoryTotal, serializer);
    sse_encode_u_64(self.memoryUsed, serializer);
    sse_encode_u_32(self.cpuCores, serializer);
    sse_encode_u_32(self.cpuThreads, serializer);
    sse_encode_String(self.cpuName, serializer);
    sse_encode_f_64(self.cpuUsage, serializer);
  }

  @protected
  void sse_encode_traffic_stats(TrafficStats self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_64(self.upload, serializer);
    sse_encode_u_64(self.download, serializer);
    sse_encode_u_64(self.uploadSpeed, serializer);
    sse_encode_u_64(self.downloadSpeed, serializer);
  }

  @protected
  void sse_encode_tun_status(TunStatus self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_bool(self.enabled, serializer);
    sse_encode_opt_String(self.interfaceName, serializer);
    sse_encode_opt_box_autoadd_u_32(self.mtu, serializer);
    sse_encode_opt_String(self.error, serializer);
  }

  @protected
  void sse_encode_u_16(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint16(self);
  }

  @protected
  void sse_encode_u_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint32(self);
  }

  @protected
  void sse_encode_u_64(BigInt self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putBigUint64(self);
  }

  @protected
  void sse_encode_u_8(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint8(self);
  }

  @protected
  void sse_encode_unit(void self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
  }
}
